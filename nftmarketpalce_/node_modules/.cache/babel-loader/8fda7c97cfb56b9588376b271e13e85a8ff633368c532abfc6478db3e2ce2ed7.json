{"ast":null,"code":"import { JsonRpcProvider, WebSocketProvider } from '@ethersproject/providers';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport axios from 'axios';\n\n/**\r\n * The supported networks by Alchemy. Note that some functions are not available\r\n * on all networks. Please refer to the Alchemy documentation for more details.\r\n *\r\n * @public\r\n */\nvar Network;\n(function (Network) {\n  Network[\"ETH_MAINNET\"] = \"eth-mainnet\";\n  Network[\"ETH_ROPSTEN\"] = \"eth-ropsten\";\n  Network[\"ETH_GOERLI\"] = \"eth-goerli\";\n  Network[\"ETH_KOVAN\"] = \"eth-kovan\";\n  Network[\"ETH_RINKEBY\"] = \"eth-rinkeby\";\n  Network[\"OPT_MAINNET\"] = \"opt-mainnet\";\n  Network[\"OPT_KOVAN\"] = \"opt-kovan\";\n  Network[\"ARB_MAINNET\"] = \"arb-mainnet\";\n  Network[\"ARB_RINKEBY\"] = \"arb-rinkeby\";\n  Network[\"MATIC_MAINNET\"] = \"polygon-mainnet\";\n  Network[\"MATIC_MUMBAI\"] = \"polygon-mumbai\";\n})(Network || (Network = {}));\n/** @public */\nvar AssetTransfersCategory;\n(function (AssetTransfersCategory) {\n  AssetTransfersCategory[\"EXTERNAL\"] = \"external\";\n  AssetTransfersCategory[\"INTERNAL\"] = \"internal\";\n  AssetTransfersCategory[\"TOKEN\"] = \"token\";\n  AssetTransfersCategory[\"ERC20\"] = \"erc20\";\n  AssetTransfersCategory[\"ERC721\"] = \"erc721\";\n  AssetTransfersCategory[\"ERC1155\"] = \"erc1155\";\n  /**\r\n   * Special contracts that don't follow ERC 721/1155, (ex: CryptoKitties).\r\n   *\r\n   * @beta\r\n   */\n  AssetTransfersCategory[\"SPECIALNFT\"] = \"specialnft\";\n})(AssetTransfersCategory || (AssetTransfersCategory = {}));\n/** @public */\nvar AssetTransfersOrder;\n(function (AssetTransfersOrder) {\n  AssetTransfersOrder[\"ASCENDING\"] = \"asc\";\n  AssetTransfersOrder[\"DESCENDING\"] = \"desc\";\n})(AssetTransfersOrder || (AssetTransfersOrder = {}));\n/** @public */\nvar NftTokenType;\n(function (NftTokenType) {\n  NftTokenType[\"ERC721\"] = \"ERC721\";\n  NftTokenType[\"ERC1155\"] = \"ERC1155\";\n  NftTokenType[\"UNKNOWN\"] = \"UNKNOWN\";\n})(NftTokenType || (NftTokenType = {}));\n/**\r\n * Enum of NFT filters that can be applied to a {@link getNftsForOwner} request.\r\n * NFTs that match one or more of these filters are excluded from the response.\r\n *\r\n * @beta\r\n */\nvar NftExcludeFilters;\n(function (NftExcludeFilters) {\n  /** Exclude NFTs that have been classified as spam. */\n  NftExcludeFilters[\"SPAM\"] = \"SPAM\";\n})(NftExcludeFilters || (NftExcludeFilters = {}));\nconst DEFAULT_CONTRACT_ADDRESSES = 'DEFAULT_TOKENS';\nconst DEFAULT_ALCHEMY_API_KEY = 'demo';\nconst DEFAULT_NETWORK = Network.ETH_MAINNET;\nconst DEFAULT_MAX_RETRIES = 5;\n/**\r\n * Returns the base URL for making Alchemy API requests. The `alchemy.com`\r\n * endpoints only work with non eth json-rpc requests.\r\n *\r\n * @internal\r\n */\nfunction getAlchemyHttpUrl(network, apiKey) {\n  return `https://${network}.g.alchemy.com/v2/${apiKey}`;\n}\nfunction getAlchemyNftHttpUrl(network, apiKey) {\n  return `https://${network}.g.alchemy.com/nft/v2/${apiKey}`;\n}\nfunction getAlchemyWsUrl(network, apiKey) {\n  return `wss://${network}.g.alchemy.com/v2/${apiKey}`;\n}\nvar AlchemyApiType;\n(function (AlchemyApiType) {\n  AlchemyApiType[AlchemyApiType[\"BASE\"] = 0] = \"BASE\";\n  AlchemyApiType[AlchemyApiType[\"NFT\"] = 1] = \"NFT\";\n})(AlchemyApiType || (AlchemyApiType = {}));\n/**\r\n * Mapping of network names to their corresponding Network strings used to\r\n * create an Ethers.js Provider instance.\r\n */\nconst EthersNetwork = {\n  [Network.ETH_MAINNET]: 'mainnet',\n  [Network.ETH_ROPSTEN]: 'ropsten',\n  [Network.ETH_GOERLI]: 'goerli',\n  [Network.ETH_KOVAN]: 'kovan',\n  [Network.ETH_RINKEBY]: 'rinkeby',\n  [Network.OPT_MAINNET]: 'optimism',\n  [Network.OPT_KOVAN]: 'optimism-kovan',\n  [Network.ARB_MAINNET]: 'arbitrum',\n  [Network.ARB_RINKEBY]: 'arbitrum-rinkeby',\n  [Network.MATIC_MAINNET]: 'matic',\n  [Network.MATIC_MUMBAI]: 'maticmum'\n};\nfunction noop() {\n  // It's a no-op\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n    i,\n    q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n}\n\n/**\r\n * The SDK has 4 log levels and a 5th option for disabling all logging. By\r\n * default, the log level is set to INFO.\r\n *\r\n * The order is a follows: DEBUG < INFO < WARN < ERROR\r\n *\r\n * All log types above the current log level will be outputted.\r\n */\nvar LogLevel;\n(function (LogLevel) {\n  LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel[LogLevel[\"INFO\"] = 1] = \"INFO\";\n  LogLevel[LogLevel[\"WARN\"] = 2] = \"WARN\";\n  LogLevel[LogLevel[\"ERROR\"] = 3] = \"ERROR\";\n  LogLevel[LogLevel[\"SILENT\"] = 4] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst logLevelStringToEnum = {\n  debug: LogLevel.DEBUG,\n  info: LogLevel.INFO,\n  warn: LogLevel.WARN,\n  error: LogLevel.ERROR,\n  silent: LogLevel.SILENT\n};\n// HACKY: Use the console method as a string rather than the function itself\n// in order to allow for mocking in tests.\nconst logLevelToConsoleFn = {\n  [LogLevel.DEBUG]: 'log',\n  [LogLevel.INFO]: 'info',\n  [LogLevel.WARN]: 'warn',\n  [LogLevel.ERROR]: 'error'\n};\nconst DEFAULT_LOG_LEVEL = LogLevel.INFO;\n/**\r\n * Configures the verbosity of logging. The default log level is `info`.\r\n *\r\n * @param logLevel - The verbosity of logging. Can be any of the following values:\r\n *\r\n *   - `debug`: The most verbose logging level.\r\n *   - `info`: The default logging level.\r\n *   - `warn`: A logging level for non-critical issues.\r\n *   - `error`: A logging level for critical issues.\r\n *   - `silent`: Turn off all logging.\r\n *\r\n * @public\r\n */\nfunction setLogLevel(logLevel) {\n  loggerClient.logLevel = logLevelStringToEnum[logLevel];\n}\nfunction logDebug(message) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  loggerClient.debug(message, args);\n}\nfunction logInfo(message) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  loggerClient.info(message, args);\n}\nfunction logWarn(message) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n  loggerClient.warn(message, args);\n}\nclass Logger {\n  constructor() {\n    /** The log level of the given Logger instance. */\n    this._logLevel = DEFAULT_LOG_LEVEL;\n  }\n  get logLevel() {\n    return this._logLevel;\n  }\n  set logLevel(val) {\n    if (!(val in LogLevel)) {\n      throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n    }\n    this._logLevel = val;\n  }\n  debug() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    this._log(LogLevel.DEBUG, ...args);\n  }\n  info() {\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    this._log(LogLevel.INFO, ...args);\n  }\n  warn() {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    this._log(LogLevel.WARN, ...args);\n  }\n  error() {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    this._log(LogLevel.ERROR, ...args);\n  }\n  /**\r\n   * Forwards log messages to their corresponding console counterparts if the\r\n   * log level allows it.\r\n   */\n  _log(logLevel) {\n    if (logLevel < this._logLevel) {\n      return;\n    }\n    const now = new Date().toISOString();\n    const method = logLevelToConsoleFn[logLevel];\n    if (method) {\n      for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        args[_key8 - 1] = arguments[_key8];\n      }\n      console[method](`[${now}] Alchemy:`, ...args.map(stringify));\n    } else {\n      throw new Error(`Logger received an invalid logLevel (value: ${logLevel})`);\n    }\n  }\n}\nfunction stringify(obj) {\n  if (typeof obj === 'string') {\n    return obj;\n  } else {\n    try {\n      return JSON.stringify(obj);\n    } catch (e) {\n      // Failed to convert to JSON, log the object directly.\n      return obj;\n    }\n  }\n}\n// Instantiate default logger for the SDK.\nconst loggerClient = new Logger();\n\n// This file is autogenerated by injectVersion.js. Any changes will be\n// overwritten on commit!\nconst VERSION = '1.1.1';\n\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * @public\r\n */\nclass AlchemyProvider extends JsonRpcProvider {\n  constructor(network, apiKey, maxRetries) {\n    // Normalize the API Key to a string.\n    apiKey = AlchemyProvider.getApiKey(apiKey);\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'http');\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(connection, ethersNetwork);\n    this.apiKey = apiKey;\n    this.maxRetries = maxRetries;\n  }\n  /**\r\n   * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n   * ethers.js. Returns the API key for an Alchemy provider.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  static getApiKey(apiKey) {\n    if (apiKey == null) {\n      return DEFAULT_ALCHEMY_API_KEY;\n    }\n    if (apiKey && typeof apiKey !== 'string') {\n      throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\n    }\n    return apiKey;\n  }\n  /**\r\n   * Converts the `Networkish` input to the network enum used by Alchemy.\r\n   *\r\n   * @internal\r\n   */\n  static getAlchemyNetwork(network) {\n    if (network === undefined) {\n      return DEFAULT_NETWORK;\n    }\n    if (typeof network === 'number') {\n      throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\n    }\n    // Guaranteed that `typeof network === 'string`.\n    const isValidNetwork = Object.values(Network).includes(network);\n    if (!isValidNetwork) {\n      throw new Error(`Invalid network '${network}' provided. Network must be one of: ` + `${Object.values(Network).join(', ')}.`);\n    }\n    return network;\n  }\n  /**\r\n   * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n   * the correct URLs for Alchemy.\r\n   *\r\n   * @internal\r\n   */\n  static getAlchemyConnectionInfo(network, apiKey, type) {\n    const url = type === 'http' ? getAlchemyHttpUrl(network, apiKey) : getAlchemyWsUrl(network, apiKey);\n    return {\n      headers: {\n        'Alchemy-Ethers-Sdk-Version': VERSION,\n        'Accept-Encoding': 'gzip'\n      },\n      allowGzip: true,\n      url\n    };\n  }\n  /**\r\n   * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n   * method is called when calling methods on the parent class `BaseProvider`.\r\n   *\r\n   * @override\r\n   */\n  detectNetwork() {\n    const _super = Object.create(null, {\n      detectNetwork: {\n        get: () => super.detectNetwork\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      let network = this.network;\n      if (network == null) {\n        network = yield _super.detectNetwork.call(this);\n        if (!network) {\n          throw new Error('No network detected');\n        }\n      }\n      return network;\n    });\n  }\n  _startPending() {\n    logWarn('WARNING: Alchemy Provider does not support pending filters');\n  }\n  /**\r\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n   * current api key is the default key.\r\n   *\r\n   * @override\r\n   */\n  isCommunityResource() {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n  /**\r\n   * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n   * logic for sending requests to Alchemy.\r\n   *\r\n   * @param method The method name to use for the request.\r\n   * @param params The parameters to use for the request.\r\n   * @override\r\n   * @public\r\n   */\n  // TODO: Implement sender logic to override retries and backoff.\n  send(method, params) {\n    return super.send(method, params);\n  }\n}\n\n/**\r\n * Converts a hex string to a decimal number.\r\n *\r\n * @param hexString - The hex string to convert.\r\n * @public\r\n */\nfunction fromHex(hexString) {\n  return BigNumber.from(hexString).toNumber();\n}\n/**\r\n * Converts a number to a hex string.\r\n *\r\n * @param num - The number to convert to hex.\r\n * @public\r\n */\nfunction toHex(num) {\n  return BigNumber.from(num).toHexString();\n}\n/**\r\n * Checks if a value is a hex string.\r\n *\r\n * @param possibleHexString - The value to check.\r\n * @public\r\n */\nfunction isHex(possibleHexString) {\n  return /^0x[0-9a-fA-F]+$/.test(possibleHexString);\n}\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\nclass WebsocketBackfiller {\n  constructor(provider) {\n    this.provider = provider;\n    // TODO: Use HTTP provider to do backfill.\n    this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  }\n  /**\r\n   * Runs backfill for `newHeads` events.\r\n   *\r\n   * @param isCancelled Whether the backfill request is cancelled.\r\n   * @param previousHeads Previous head requests that were sent.\r\n   * @param fromBlockNumber The block number to start backfilling from.\r\n   * @returns A list of `newHeads` events that were sent since the last backfill.\r\n   */\n  getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throwIfCancelled(isCancelled);\n      const toBlockNumber = yield this.getBlockNumber();\n      throwIfCancelled(isCancelled);\n      // If there are no previous heads to fetch, return new heads since\n      // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n      if (previousHeads.length === 0) {\n        return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n      }\n      // If the last emitted event is too far back in the past, there's no need\n      // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n      // new heads.\n      const lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\n      const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n      if (lastSeenBlockNumber <= minBlockNumber) {\n        return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n      }\n      // To capture all `newHeads` events, return all head events from the last\n      // seen block number to current + any of the previous heads that were re-orged.\n      const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\n      throwIfCancelled(isCancelled);\n      const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\n      throwIfCancelled(isCancelled);\n      return [...reorgHeads, ...intermediateHeads];\n    });\n  }\n  /**\r\n   * Runs backfill for `logs` events.\r\n   *\r\n   * @param isCancelled Whether the backfill request is cancelled.\r\n   * @param filter The filter object that accompanies a logs subscription.\r\n   * @param previousLogs Previous log requests that were sent.\r\n   * @param fromBlockNumber The block number to start backfilling from.\r\n   */\n  getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throwIfCancelled(isCancelled);\n      const toBlockNumber = yield this.getBlockNumber();\n      throwIfCancelled(isCancelled);\n      // If there are no previous logs to fetch, return new logs since\n      // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n      if (previousLogs.length === 0) {\n        return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n      }\n      // If the last emitted log is too far back in the past, there's no need\n      // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n      // worth of logs.\n      const lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\n      const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n      if (lastSeenBlockNumber < minBlockNumber) {\n        return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n      }\n      // Return all log events that have happened along with log events that have\n      // been removed due to a chain reorg.\n      const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\n      throwIfCancelled(isCancelled);\n      // All previous logs with a block number greater than the common ancestor\n      // were part of a re-org, so mark them as such.\n      const removedLogs = previousLogs.filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber).map(log => Object.assign(Object.assign({}, log), {\n        removed: true\n      }));\n      // If no common ancestor was found, start backfill from the oldest log's\n      // block number.\n      const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY ? fromHex(previousLogs[0].blockNumber) : commonAncestor.blockNumber;\n      let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\n      // De-dupe any logs that were already emitted.\n      addedLogs = addedLogs.filter(log => log && (fromHex(log.blockNumber) > commonAncestor.blockNumber || fromHex(log.logIndex) > commonAncestor.logIndex));\n      throwIfCancelled(isCancelled);\n      return [...removedLogs, ...addedLogs];\n    });\n  }\n  /**\r\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n   *\r\n   * @internal\r\n   */\n  setMaxBackfillBlock(newMax) {\n    this.maxBackfillBlocks = newMax;\n  }\n  /**\r\n   * Gets the current block number as a number.\r\n   *\r\n   * @private\r\n   */\n  getBlockNumber() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const blockNumberHex = yield this.provider.send('eth_blockNumber');\n      return fromHex(blockNumberHex);\n    });\n  }\n  /**\r\n   * Gets all `newHead` events in the provided range. Note that the returned\r\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n   * that were part of a re-org.\r\n   *\r\n   * @private\r\n   */\n  getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (fromBlockInclusive >= toBlockExclusive) {\n        return [];\n      }\n      const batchParts = [];\n      for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n        batchParts.push({\n          method: 'eth_getBlockByNumber',\n          params: [toHex(i), false]\n        });\n      }\n      // TODO: just fire off each send() separately since we're no longer batching:\n      // TODO: handle errors\n      const batchedBlockHeads = yield this.provider.sendBatch(batchParts);\n      const blockHeads = batchedBlockHeads.reduce((acc, batch) => acc.concat(batch), []);\n      return blockHeads.map(toNewHeadsEvent);\n    });\n  }\n  /**\r\n   * Returns all heads that were part of a reorg event.\r\n   *\r\n   * @private\r\n   */\n  getReorgHeads(isCancelled, previousHeads) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = [];\n      // Iterate from the most recent head backwards in order to find the first\n      // block that was part of a re-org.\n      for (let i = previousHeads.length - 1; i >= 0; i--) {\n        const oldEvent = previousHeads[i];\n        const blockHead = yield this.getBlockByNumber(fromHex(oldEvent.number));\n        throwIfCancelled(isCancelled);\n        // If the hashes match, then current head in the iteration was not re-orged.\n        if (oldEvent.hash === blockHead.hash) {\n          break;\n        }\n        result.push(toNewHeadsEvent(blockHead));\n      }\n      return result.reverse();\n    });\n  }\n  /**\r\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n   * block information for the provided block number.\r\n   *\r\n   * @private\r\n   */\n  getBlockByNumber(blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.provider.send('eth_getBlockByNumber', [toHex(blockNumber), false]);\n    });\n  }\n  /**\r\n   * Given a list of previous log events, finds the common block number from the\r\n   * logs that matches the block head.\r\n   *\r\n   * This can be used to identify which logs are part of a re-org.\r\n   *\r\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n   *\r\n   * @private\r\n   */\n  getCommonAncestor(isCancelled, previousLogs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Iterate from the most recent head backwards in order to find the first\n      // block that was part of a re-org.\n      let blockHead = yield this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));\n      throwIfCancelled(isCancelled);\n      for (let i = previousLogs.length - 1; i >= 0; i--) {\n        const oldLog = previousLogs[i];\n        // Ensure that updated blocks are fetched every time the log's block number\n        // changes.\n        if (oldLog.blockNumber !== blockHead.number) {\n          blockHead = yield this.getBlockByNumber(fromHex(oldLog.blockNumber));\n        }\n        // Since logs are ordered in ascending order, the first log that matches\n        // the hash should be the largest logIndex.\n        if (oldLog.blockHash === blockHead.hash) {\n          return {\n            blockNumber: fromHex(oldLog.blockNumber),\n            logIndex: fromHex(oldLog.logIndex)\n          };\n        }\n      }\n      return {\n        blockNumber: Number.NEGATIVE_INFINITY,\n        logIndex: Number.NEGATIVE_INFINITY\n      };\n    });\n  }\n  /**\r\n   * Gets all `logs` events in the provided range. Note that the returned logs\r\n   * do not include removed logs.\r\n   *\r\n   * @private\r\n   */\n  getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (fromBlockInclusive >= toBlockExclusive) {\n        return [];\n      }\n      const rangeFilter = Object.assign(Object.assign({}, filter), {\n        fromBlock: toHex(fromBlockInclusive),\n        toBlock: toHex(toBlockExclusive - 1)\n      });\n      return this.provider.send('eth_getLogs', [rangeFilter]);\n    });\n  }\n}\nfunction toNewHeadsEvent(head) {\n  const result = Object.assign({}, head);\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\nfunction dedupeNewHeads(events) {\n  return dedupe(events, event => event.hash);\n}\nfunction dedupeLogs(events) {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\nfunction dedupe(items, getKey) {\n  const keysSeen = new Set();\n  const result = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\nconst CANCELLED = new Error('Cancelled');\nfunction throwIfCancelled(isCancelled) {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Event class copied directly over from ethers.js's `BaseProvider` class.\r\n *\r\n * This class is used to represent events and their corresponding listeners. The\r\n * SDK needs to extend this class in order to support Alchemy's custom\r\n * Subscription API types. The original class is not exported by ethers. Minimal\r\n * changes have been made in order to get TS to compile.\r\n */\nclass Event {\n  constructor(tag, listener, once) {\n    this.listener = listener;\n    this.tag = tag;\n    this.once = once;\n    this._lastBlockNumber = -2;\n    this._inflight = false;\n  }\n  get event() {\n    switch (this.type) {\n      case 'tx':\n        return this.hash;\n      case 'filter':\n        return this.filter;\n      default:\n        return this.tag;\n    }\n  }\n  get type() {\n    return this.tag.split(':')[0];\n  }\n  get hash() {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'tx') {\n      throw new Error('Not a transaction event');\n    }\n    return comps[1];\n  }\n  get filter() {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'filter') {\n      throw new Error('Not a transaction event');\n    }\n    const address = comps[1];\n    const topics = deserializeTopics(comps[2]);\n    const filter = {};\n    if (topics.length > 0) {\n      filter.topics = topics;\n    }\n    if (address && address !== '*') {\n      filter.address = address;\n    }\n    return filter;\n  }\n  pollable() {\n    const PollableEvents = ['block', 'network', 'pending', 'poll'];\n    return this.tag.indexOf(':') >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n  }\n}\n/**\r\n * Wrapper class around the ethers `Event` class in order to add support for\r\n * Alchemy's custom subscriptions types.\r\n */\nclass EthersEvent extends Event {\n  get address() {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'alchemy') {\n      return null;\n    }\n    if (comps[1] && comps[1] !== '*') {\n      return comps[1];\n    } else {\n      return null;\n    }\n  }\n}\nfunction deserializeTopics(data) {\n  if (data === '') {\n    return [];\n  }\n  return data.split(/&/g).map(topic => {\n    if (topic === '') {\n      return [];\n    }\n    const comps = topic.split('|').map(topic => {\n      return topic === 'null' ? null : topic;\n    });\n    return comps.length === 1 ? comps[0] : comps;\n  });\n}\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\nclass AlchemyWebSocketProvider extends WebSocketProvider {\n  /**\r\n   * DO NOT CALL THIS CONSTRUCTOR DIRECTLY. Instead, use `Alchemy.getWebsocketProvider()`.\r\n   *\r\n   * @param network Requires one of the Alchemy `Network` enums\r\n   * @param apiKey The api key, or defaults to `demo`.\r\n   * @param wsConstructor Optional WebSocket constructor. Currently, used only\r\n   *   for testing purposes.\r\n   * @internal\r\n   */\n  constructor(network, apiKey, wsConstructor) {\n    // Normalize the API Key to a string.\n    apiKey = AlchemyProvider.getApiKey(apiKey);\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\n    const protocol = `alchemy-sdk-${VERSION}`;\n    const ws = new SturdyWebSocket(connection.url, protocol, {\n      wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\n    });\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws, ethersNetwork);\n    this._events = [];\n    // In the case of a WebSocket reconnection, all subscriptions are lost and we\n    // create new ones to replace them, but we want to create the illusion that\n    // the original subscriptions persist. Thus, maintain a mapping from the\n    // \"virtual\" subscription ids which are visible to the consumer to the\n    // \"physical\" subscription ids of the actual connections. This terminology is\n    // borrowed from virtual and physical memory, which has a similar mapping.\n    /** @internal */\n    this.virtualSubscriptionsById = new Map();\n    /** @internal */\n    this.virtualIdsByPhysicalId = new Map();\n    /**\r\n     * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n     * messages. To allow backfilling, track all messages that are emitted.\r\n     *\r\n     * This is a field arrow function in order to preserve `this` context when\r\n     * passing the method as an event listener.\r\n     *\r\n     * @internal\r\n     */\n    this.handleMessage = event => {\n      const message = JSON.parse(event.data);\n      if (!isSubscriptionEvent(message)) {\n        return;\n      }\n      const physicalId = message.params.subscription;\n      const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n      if (!virtualId) {\n        return;\n      }\n      const subscription = this.virtualSubscriptionsById.get(virtualId);\n      if (subscription.method !== 'eth_subscribe') {\n        return;\n      }\n      switch (subscription.params[0]) {\n        case 'newHeads':\n          {\n            const newHeadsSubscription = subscription;\n            const newHeadsMessage = message;\n            const {\n              isBackfilling,\n              backfillBuffer\n            } = newHeadsSubscription;\n            const {\n              result\n            } = newHeadsMessage.params;\n            if (isBackfilling) {\n              addToNewHeadsEventsBuffer(backfillBuffer, result);\n            } else if (physicalId !== virtualId) {\n              // In the case of a re-opened subscription, ethers will not emit the\n              // event, so the SDK has to.\n              this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n            } else {\n              // Ethers subscription mapping will emit the event, just store it.\n              this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n            }\n            break;\n          }\n        case 'logs':\n          {\n            const logsSubscription = subscription;\n            const logsMessage = message;\n            const {\n              isBackfilling,\n              backfillBuffer\n            } = logsSubscription;\n            const {\n              result\n            } = logsMessage.params;\n            if (isBackfilling) {\n              addToLogsEventsBuffer(backfillBuffer, result);\n            } else if (virtualId !== physicalId) {\n              this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n            } else {\n              this.rememberEvent(virtualId, result, getLogsBlockNumber);\n            }\n            break;\n          }\n      }\n    };\n    /**\r\n     * When the websocket connection reopens:\r\n     *\r\n     * 1. Resubscribe to all existing subscriptions and start backfilling\r\n     * 2. Restart heart beat.\r\n     *\r\n     * This is a field arrow function in order to preserve `this` context when\r\n     * passing the method as an event listener.\r\n     *\r\n     * @internal\r\n     */\n    this.handleReopen = () => {\n      this.virtualIdsByPhysicalId.clear();\n      const {\n        cancel,\n        isCancelled\n      } = makeCancelToken();\n      this.cancelBackfill = cancel;\n      for (const subscription of this.virtualSubscriptionsById.values()) {\n        void (() => __awaiter(this, void 0, void 0, function* () {\n          try {\n            yield this.resubscribeAndBackfill(isCancelled, subscription);\n          } catch (error) {\n            if (!isCancelled()) {\n              console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\n            }\n          }\n        }))();\n      }\n      this.startHeartbeat();\n    };\n    /**\r\n     * Cancels the heartbeat and any pending backfills being performed. This is\r\n     * called when the websocket connection goes down or is disconnected.\r\n     *\r\n     * This is a field arrow function in order to preserve `this` context when\r\n     * passing the method as an event listener.\r\n     *\r\n     * @internal\r\n     */\n    this.stopHeartbeatAndBackfill = () => {\n      if (this.heartbeatIntervalId != null) {\n        clearInterval(this.heartbeatIntervalId);\n        this.heartbeatIntervalId = undefined;\n      }\n      this.cancelBackfill();\n    };\n    this.apiKey = apiKey;\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n  /**\r\n   * Overridden implementation of ethers' that includes Alchemy based subscriptions.\r\n   *\r\n   * @param eventName Event to subscribe to\r\n   * @param listener The listener function to call when the event is triggered.\r\n   * @override\r\n   * @public\r\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName, listener) {\n    return this._addEventListener(eventName, listener, false);\n  }\n  /**\r\n   * Overrides the method in `BaseProvider` in order to properly format the\r\n   * Alchemy subscription events.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  _addEventListener(eventName, listener, once) {\n    if (isAlchemyEvent(eventName)) {\n      const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n  /**\r\n   * Overrides the `_startEvent()` method in ethers.js's\r\n   * {@link WebSocketProvider} to include additional alchemy methods.\r\n   *\r\n   * @param event\r\n   * @override\r\n   * @internal\r\n   */\n  _startEvent(event) {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = ['alchemy', 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n  /**\r\n   * Overridden from ethers.js's {@link WebSocketProvider}\r\n   *\r\n   * Modified in order to add mappings for backfilling.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  _subscribe(tag, param, processFunc, event) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let subIdPromise = this._subIds[tag];\n      // BEGIN MODIFIED CODE\n      const startingBlockNumber = yield this.getBlockNumber();\n      // END MODIFIED CODE\n      if (subIdPromise == null) {\n        subIdPromise = Promise.all(param).then(param => {\n          return this.send('eth_subscribe', param);\n        });\n        this._subIds[tag] = subIdPromise;\n      }\n      const subId = yield subIdPromise;\n      // BEGIN MODIFIED CODE\n      const resolvedParams = yield Promise.all(param);\n      this.virtualSubscriptionsById.set(subId, {\n        event: event,\n        method: 'eth_subscribe',\n        params: resolvedParams,\n        startingBlockNumber,\n        virtualId: subId,\n        physicalId: subId,\n        sentEvents: [],\n        isBackfilling: false,\n        backfillBuffer: []\n      });\n      this.virtualIdsByPhysicalId.set(subId, subId);\n      // END MODIFIED CODE\n      this._subs[subId] = {\n        tag,\n        processFunc\n      };\n    });\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `BaseProvider`.\r\n   *\r\n   * This method is copied over directly in order to implement Alchemy's unique\r\n   * subscription types. The only difference is that this method calls\r\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n   * order to parse the Alchemy subscription event.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  emit(eventName) {\n    for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n      args[_key9 - 1] = arguments[_key9];\n    }\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n      const stopped = [];\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n        result = true;\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n        return true;\n      });\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n  /** @internal */\n  sendBatch(parts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let nextId = 0;\n      const payload = parts.map(_ref => {\n        let {\n          method,\n          params\n        } = _ref;\n        return {\n          method,\n          params,\n          jsonrpc: '2.0',\n          id: `alchemy-sdk:${nextId++}`\n        };\n      });\n      const response = yield this.sendBatchConcurrently(payload);\n      const errorResponse = response.find(r => !!r.error);\n      if (errorResponse) {\n        throw new Error(errorResponse.error.message);\n      }\n      // The ids are ascending numbers because that's what Payload Factories do.\n      return response.sort((r1, r2) => r1.id - r2.id).map(r => r.result);\n    });\n  }\n  /** @override */\n  destroy() {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n  /**\r\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n   * current api key is the default key.\r\n   *\r\n   * @override\r\n   */\n  isCommunityResource() {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n  /** @internal */\n  addSocketListeners() {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n  /** @internal */\n  removeSocketListeners() {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n  /**\r\n   * Reopens the backfill based on\r\n   *\r\n   * @param isCancelled\r\n   * @param subscription\r\n   * @internal\r\n   */\n  resubscribeAndBackfill(isCancelled, subscription) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        virtualId,\n        method,\n        params,\n        sentEvents,\n        backfillBuffer,\n        startingBlockNumber\n      } = subscription;\n      subscription.isBackfilling = true;\n      backfillBuffer.length = 0;\n      try {\n        const physicalId = yield this.send(method, params);\n        throwIfCancelled(isCancelled);\n        subscription.physicalId = physicalId;\n        this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n        switch (params[0]) {\n          case 'newHeads':\n            {\n              const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\n              throwIfCancelled(isCancelled);\n              const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n              events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n              break;\n            }\n          case 'logs':\n            {\n              const filter = params[1] || {};\n              const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\n              throwIfCancelled(isCancelled);\n              const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n              events.forEach(event => this.emitLogsEvent(virtualId, event));\n              break;\n            }\n          default:\n            break;\n        }\n      } finally {\n        subscription.isBackfilling = false;\n        backfillBuffer.length = 0;\n      }\n    });\n  }\n  /** @internal */\n  emitNewHeadsEvent(virtualId, result) {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n  /** @internal */\n  emitLogsEvent(virtualId, result) {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n  /**\r\n   * Emits an event to consumers, but also remembers it in its subscriptions's\r\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n   * and needs to be reconnected.\r\n   *\r\n   * @internal\r\n   */\n  emitAndRememberEvent(virtualId, result, getBlockNumber) {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n  /** @internal */\n  rememberEvent(virtualId, result, getBlockNumber) {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\n  }\n  /** @internal */\n  emitGenericEvent(subscription, result) {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n  /**\r\n   * Starts a heartbeat that pings the websocket server periodically to ensure\r\n   * that the connection stays open.\r\n   *\r\n   * @internal\r\n   */\n  startHeartbeat() {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch (_a) {\n        this._websocket.reconnect();\n      }\n    }), HEARTBEAT_INTERVAL);\n  }\n  /**\r\n   * This method sends the batch concurrently as individual requests rather than\r\n   * as a batch, which was the original implementation. The original batch logic\r\n   * is preserved in this implementation in order for faster porting.\r\n   *\r\n   * @param payload\r\n   * @internal\r\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  sendBatchConcurrently(payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.all(payload.map(req => this.send(req.method, req.params)));\n    });\n  }\n  /** @internal */\n  customStartEvent(event) {\n    if (event.type === 'alchemy') {\n      const {\n        address\n      } = event;\n      if (!!address) {\n        void this._subscribe(event.tag, ['alchemy_filteredNewFullPendingTransactions', {\n          address\n        }], this.emitProcessFn(event), event);\n      } else {\n        void this._subscribe(event.tag, ['alchemy_newFullPendingTransactions'], this.emitProcessFn(event), event);\n      }\n    } else if (event.type === 'block') {\n      void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\n    } else if (event.type === 'filter') {\n      void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\n    }\n  }\n  /** @internal */\n  emitProcessFn(event) {\n    switch (event.type) {\n      case 'alchemy':\n        const {\n          address\n        } = event;\n        if (!!address) {\n          return result => this.emit({\n            method: 'alchemy_filteredNewFullPendingTransactions',\n            address: event.address\n          }, result);\n        } else {\n          return result => this.emit({\n            method: 'alchemy_newFullPendingTransactions'\n          }, result);\n        }\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n}\nfunction getWebsocketConstructor() {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\nfunction isNodeEnvironment() {\n  return typeof process !== 'undefined' && process != null && process.versions != null && process.versions.node != null;\n}\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken() {\n  let cancelled = false;\n  return {\n    cancel: () => cancelled = true,\n    isCancelled: () => cancelled\n  };\n}\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\nfunction withBackoffRetries(f, retryCount) {\n  let shouldRetry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => true;\n  return __awaiter(this, void 0, void 0, function* () {\n    let nextWaitTime = 0;\n    let i = 0;\n    while (true) {\n      try {\n        return yield f();\n      } catch (error) {\n        i++;\n        if (i >= retryCount || !shouldRetry(error)) {\n          throw error;\n        }\n        yield delay(nextWaitTime);\n        if (!shouldRetry(error)) {\n          throw error;\n        }\n        nextWaitTime = nextWaitTime === 0 ? MIN_RETRY_DELAY : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n      }\n    }\n  });\n}\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction withTimeout(promise, ms) {\n  return Promise.race([promise, new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))]);\n}\nfunction getNewHeadsBlockNumber(event) {\n  return fromHex(event.number);\n}\nfunction getLogsBlockNumber(event) {\n  return fromHex(event.blockNumber);\n}\nfunction isResponse(message) {\n  return Array.isArray(message) || message.jsonrpc === '2.0' && message.id !== undefined;\n}\nfunction isSubscriptionEvent(message) {\n  return !isResponse(message);\n}\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\nfunction addToLogsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\nfunction isAlchemyEvent(event) {\n  return typeof event === 'object' && 'method' in event;\n}\nfunction getAlchemyEventTag(event) {\n  if (!isAlchemyEvent(event)) {\n    throw new Error('Event tag requires AlchemyEventType');\n  }\n  return 'alchemy:' + ('address' in event && event.address || '*');\n}\n\n/**\r\n * Entry point into the Alchemy SDK.\r\n *\r\n * @param config - Configuration object for the Alchemy SDK\r\n * @public\r\n */\nfunction initializeAlchemy(config) {\n  return new Alchemy(config);\n}\n/**\r\n * The Alchemy SDK client. This class holds config information and must be\r\n * passed into SDK methods.\r\n *\r\n * Do not call this constructor directly. Instead, use {@link initializeAlchemy}\r\n * to get an instance of the SDK.\r\n *\r\n * @public\r\n */\nclass Alchemy {\n  /**\r\n   * @hideconstructor\r\n   * @internal\r\n   */\n  constructor(config) {\n    this.apiKey = (config === null || config === void 0 ? void 0 : config.apiKey) || DEFAULT_ALCHEMY_API_KEY;\n    this.network = (config === null || config === void 0 ? void 0 : config.network) || DEFAULT_NETWORK;\n    this.maxRetries = (config === null || config === void 0 ? void 0 : config.maxRetries) || DEFAULT_MAX_RETRIES;\n  }\n  /** @internal */\n  getBaseUrl() {\n    return getAlchemyHttpUrl(this.network, this.apiKey);\n  }\n  /** @internal */\n  getNftUrl() {\n    return getAlchemyNftHttpUrl(this.network, this.apiKey);\n  }\n  /**\r\n   * Changes the network that the SDK requests data from.\r\n   *\r\n   * @param network - The network to change to.\r\n   * @public\r\n   */\n  setNetwork(network) {\n    // TODO(ethers): Add support for changing the network in the returned provider.\n    this.network = network;\n  }\n  /**\r\n   * Creates an AlchemyProvider instance. Only one provider is created per\r\n   * Alchemy instance.\r\n   *\r\n   * @public\r\n   */\n  getProvider() {\n    if (!this._baseAlchemyProvider) {\n      this._baseAlchemyProvider = new AlchemyProvider(this.network, this.apiKey, this.maxRetries);\n    }\n    return this._baseAlchemyProvider;\n  }\n  /**\r\n   * Creates an AlchemyWebsocketProvider instance. Only one provider is created\r\n   * per Alchemy instance.\r\n   *\r\n   * @public\r\n   */\n  getWebsocketProvider() {\n    if (!this._baseAlchemyWssProvider) {\n      this._baseAlchemyWssProvider = new AlchemyWebSocketProvider(this.network, this.apiKey);\n    }\n    return this._baseAlchemyWssProvider;\n  }\n}\n\n/**\r\n * Given a REST endpoint, method, and params, sends the request with axios and\r\n * returns the response.\r\n */\nconst IS_BROWSER = typeof window !== 'undefined' && window !== null;\n/**\r\n * Helper function to send http requests using Axis.\r\n *\r\n * @private\r\n */\n// TODO: Support other methods besides GET + other http options.\nfunction sendAxiosRequest(baseUrl, methodName, params) {\n  const methodUrl = baseUrl + '/' + methodName;\n  const config = {\n    headers: IS_BROWSER ? {\n      'Alchemy-Ethers-Sdk-Version': VERSION\n    } : {\n      'Alchemy-Ethers-Sdk-Version': VERSION,\n      'Accept-Encoding': 'gzip'\n    },\n    method: 'get',\n    url: methodUrl,\n    params\n  };\n  return axios(config);\n}\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\nconst DEFAULT_BACKOFF_MULTIPLIER = 1.5;\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 30 * 1000;\nconst DEFAULT_BACKOFF_MAX_ATTEMPTS = 5;\n/**\r\n * Helper class for implementing exponential backoff and max retry attempts.\r\n *\r\n * @private\r\n * @internal\r\n */\nclass ExponentialBackoff {\n  constructor() {\n    let maxAttempts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_BACKOFF_MAX_ATTEMPTS;\n    this.maxAttempts = maxAttempts;\n    this.initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n    this.backoffMultiplier = DEFAULT_BACKOFF_MULTIPLIER;\n    this.maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS;\n    this.numAttempts = 0;\n    this.currentDelayMs = 0;\n    this.isInBackoff = false;\n  }\n  /**\r\n   * Returns a promise that resolves after the the backoff delay. The delay is\r\n   * increased for each attempt. The promise is rejected if the maximum number\r\n   * of attempts is exceeded.\r\n   */\n  // TODO: beautify this into an async iterator.\n  backoff() {\n    if (this.numAttempts >= this.maxAttempts) {\n      return Promise.reject(new Error(`Exceeded maximum number of attempts: ${this.maxAttempts}`));\n    }\n    if (this.isInBackoff) {\n      return Promise.reject(new Error('A backoff operation is already in progress'));\n    }\n    const backoffDelayWithJitterMs = this.withJitterMs(this.currentDelayMs);\n    if (backoffDelayWithJitterMs > 0) {\n      logDebug('ExponentialBackoff.backoff', `Backing off for ${backoffDelayWithJitterMs}ms`);\n    }\n    // Calculate the next delay.\n    this.currentDelayMs *= this.backoffMultiplier;\n    this.currentDelayMs = Math.max(this.currentDelayMs, this.initialDelayMs);\n    this.currentDelayMs = Math.min(this.currentDelayMs, this.maxDelayMs);\n    this.numAttempts += 1;\n    return new Promise(resolve => {\n      this.isInBackoff = true;\n      setTimeout(() => {\n        this.isInBackoff = false;\n        resolve();\n      }, backoffDelayWithJitterMs);\n    });\n  }\n  /**\r\n   * Applies +/- 50% jitter to the backoff delay, up to the max delay cap.\r\n   *\r\n   * @private\r\n   * @param delayMs\r\n   */\n  withJitterMs(delayMs) {\n    return Math.min(delayMs + (Math.random() - 0.5) * delayMs, this.maxDelayMs);\n  }\n}\n\n/**\r\n * A wrapper function to make http requests and retry if the request fails.\r\n *\r\n * @param alchemy\r\n * @param method\r\n * @param params\r\n * @internal\r\n */\n// TODO: Wrap Axios error in AlchemyError.\nfunction requestHttpWithBackoff(alchemy, apiType, method, params) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let lastError = undefined;\n    const backoff = new ExponentialBackoff(alchemy.maxRetries);\n    for (let attempt = 0; attempt < alchemy.maxRetries + 1; attempt++) {\n      try {\n        if (lastError !== undefined) {\n          logInfo('requestHttp', `Retrying after error: ${lastError.message}`);\n        }\n        try {\n          yield backoff.backoff();\n        } catch (err) {\n          // Backoff errors when the maximum number of attempts is reached. Break\n          // out of the loop to preserve the last error.\n          break;\n        }\n        let response;\n        switch (apiType) {\n          case AlchemyApiType.NFT:\n            response = yield sendAxiosRequest(alchemy.getNftUrl(), method, params);\n            break;\n          default:\n          case AlchemyApiType.BASE:\n            response = yield sendAxiosRequest(alchemy.getBaseUrl(), method, params);\n            break;\n        }\n        if (response.status === 200) {\n          logDebug(method, `Successful request: ${method}`);\n          return response.data;\n        } else {\n          logInfo(method, `Request failed: ${method}, ${response.status}, ${response.data}`);\n          lastError = new Error(response.status + ': ' + response.data);\n        }\n      } catch (err) {\n        if (!axios.isAxiosError(err) || err.response === undefined) {\n          throw err;\n        }\n        // TODO: Standardize all errors into AlchemyError\n        lastError = new Error(err.response.status + ': ' + err.response.data);\n        if (!isRetryableHttpError(err)) {\n          break;\n        }\n      }\n    }\n    return Promise.reject(lastError);\n  });\n}\nfunction isRetryableHttpError(err) {\n  const retryableCodes = [429];\n  return err.response !== undefined && retryableCodes.includes(err.response.status);\n}\n/**\r\n * Fetches all pages in a paginated endpoint, given a `pageKey` field that\r\n * represents the property name containing the next page token.\r\n *\r\n * @internal\r\n */\nfunction paginateEndpoint(alchemy, apiType, methodName, reqPageKey, resPageKey, params) {\n  return __asyncGenerator(this, arguments, function* paginateEndpoint_1() {\n    let hasNext = true;\n    const requestParams = Object.assign({}, params);\n    while (hasNext) {\n      const response = yield __await(requestHttpWithBackoff(alchemy, apiType, methodName, requestParams));\n      yield yield __await(response);\n      if (response[resPageKey] !== undefined) {\n        requestParams[reqPageKey] = response[resPageKey];\n      } else {\n        hasNext = false;\n      }\n    }\n  });\n}\nfunction formatBlock(block) {\n  if (typeof block === 'string') {\n    return block;\n  } else if (Number.isInteger(block)) {\n    return toHex(block);\n  }\n  return block.toString();\n}\nfunction getNftContractFromRaw(rawNftContract) {\n  return {\n    address: rawNftContract.address,\n    name: rawNftContract.contractMetadata.name,\n    symbol: rawNftContract.contractMetadata.symbol,\n    totalSupply: rawNftContract.contractMetadata.totalSupply,\n    tokenType: parseNftTokenType(rawNftContract.contractMetadata.tokenType)\n  };\n}\nfunction getBaseNftFromRaw(rawBaseNft, contractAddress) {\n  var _a;\n  return {\n    contract: {\n      address: contractAddress\n    },\n    tokenId: BigNumber.from(rawBaseNft.id.tokenId).toString(),\n    tokenType: parseNftTokenType((_a = rawBaseNft.id.tokenMetadata) === null || _a === void 0 ? void 0 : _a.tokenType)\n  };\n}\nfunction getNftFromRaw(rawNft, contractAddress) {\n  var _a;\n  return {\n    contract: {\n      address: contractAddress\n    },\n    tokenId: parseNftTokenId(rawNft.id.tokenId),\n    tokenType: parseNftTokenType((_a = rawNft.id.tokenMetadata) === null || _a === void 0 ? void 0 : _a.tokenType),\n    title: rawNft.title,\n    description: parseNftDescription(rawNft.description),\n    timeLastUpdated: rawNft.timeLastUpdated,\n    metadataError: rawNft.error,\n    rawMetadata: rawNft.metadata,\n    tokenUri: parseNftTokenUri(rawNft.tokenUri),\n    media: parseNftTokenUriArray(rawNft.media)\n  };\n}\nfunction parseNftTokenId(tokenId) {\n  // We have to normalize the token id here since the backend sometimes\n  // returns the token ID as a hex string and sometimes as an integer.\n  return BigNumber.from(tokenId).toString();\n}\nfunction parseNftTokenType(tokenType) {\n  switch (tokenType) {\n    case 'erc721':\n    case 'ERC721':\n      return NftTokenType.ERC721;\n    case 'erc1155':\n    case 'ERC1155':\n      return NftTokenType.ERC1155;\n    default:\n      return NftTokenType.UNKNOWN;\n  }\n}\nfunction parseNftDescription(description) {\n  if (description === undefined) {\n    return '';\n  }\n  return typeof description === 'string' ? description : description.join(' ');\n}\nfunction parseNftTokenUri(uri) {\n  if (uri && uri.raw.length === 0 && uri.gateway.length == 0) {\n    return undefined;\n  }\n  return uri;\n}\nfunction parseNftTokenUriArray(arr) {\n  if (arr === undefined) {\n    return [];\n  }\n  return arr.filter(uri => parseNftTokenUri(uri) !== undefined);\n}\n\n/** @public */\nfunction getTokenBalances(alchemy, address, contractAddresses) {\n  if (contractAddresses && contractAddresses.length > 1500) {\n    throw new Error('You cannot pass in more than 1500 contract addresses to getTokenBalances()');\n  }\n  return alchemy.getProvider().send('alchemy_getTokenBalances', [address, contractAddresses || DEFAULT_CONTRACT_ADDRESSES]);\n}\n/** @public */\nfunction getTokenMetadata(alchemy, address) {\n  return alchemy.getProvider().send('alchemy_getTokenMetadata', [address]);\n}\n/** @public */\nfunction getAssetTransfers(alchemy, params) {\n  return alchemy.getProvider().send('alchemy_getAssetTransfers', [Object.assign(Object.assign({}, params), {\n    fromBlock: params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,\n    toBlock: params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n    maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n  })]);\n}\n/** @public */\nfunction getTransactionReceipts(alchemy, params) {\n  return alchemy.getProvider().send('alchemy_getTransactionReceipts', [params]);\n}\nconst ETH_NULL_VALUE = '0x';\nfunction getNftMetadata(alchemy, contractAddressOrBaseNft, tokenId, tokenType) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let response;\n    let contractAddress;\n    if (typeof contractAddressOrBaseNft === 'string') {\n      contractAddress = contractAddressOrBaseNft;\n      response = yield requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getNFTMetadata', {\n        contractAddress: contractAddressOrBaseNft,\n        tokenId: BigNumber.from(tokenId).toString(),\n        tokenType: tokenType !== NftTokenType.UNKNOWN ? tokenType : undefined\n      });\n    } else {\n      contractAddress = contractAddressOrBaseNft.contract.address;\n      response = yield requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getNFTMetadata', {\n        contractAddress: contractAddressOrBaseNft.contract.address,\n        tokenId: BigNumber.from(contractAddressOrBaseNft.tokenId).toString(),\n        tokenType: contractAddressOrBaseNft.tokenType !== NftTokenType.UNKNOWN ? contractAddressOrBaseNft.tokenType : undefined\n      });\n    }\n    return getNftFromRaw(response, contractAddress);\n  });\n}\nfunction getNftContractMetadata(alchemy, contractAddressOrBaseNftContract) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let response;\n    if (typeof contractAddressOrBaseNftContract === 'string') {\n      response = yield requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getContractMetadata', {\n        contractAddress: contractAddressOrBaseNftContract\n      });\n    } else {\n      response = yield requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getContractMetadata', {\n        contractAddress: contractAddressOrBaseNftContract.address\n      });\n    }\n    return getNftContractFromRaw(response);\n  });\n}\nfunction getNftsForOwnerIterator(alchemy, owner, options) {\n  return __asyncGenerator(this, arguments, function* getNftsForOwnerIterator_1() {\n    var e_1, _a;\n    const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n    try {\n      for (var _b = __asyncValues(paginateEndpoint(alchemy, AlchemyApiType.NFT, 'getNFTs', 'pageKey', 'pageKey', {\n          contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n          pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n          filters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n          owner,\n          withMetadata\n        })), _c; _c = yield __await(_b.next()), !_c.done;) {\n        const response = _c.value;\n        for (const ownedNft of response.ownedNfts) {\n          yield yield __await(Object.assign(Object.assign({}, nftFromGetNftResponse(ownedNft)), {\n            balance: parseInt(ownedNft.balance)\n          }));\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\nfunction getNftsForOwner(alchemy, owner, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n    const response = yield requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getNFTs', {\n      contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n      pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n      filters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n      owner,\n      withMetadata\n    });\n    return {\n      ownedNfts: response.ownedNfts.map(res => Object.assign(Object.assign({}, nftFromGetNftResponse(res)), {\n        balance: parseInt(res.balance)\n      })),\n      pageKey: response.pageKey,\n      totalCount: response.totalCount\n    };\n  });\n}\nfunction getNftsForCollection(alchemy, contractAddress, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n    const response = yield requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getNFTsForCollection', {\n      contractAddress,\n      startToken: options === null || options === void 0 ? void 0 : options.pageKey,\n      withMetadata\n    });\n    return {\n      nfts: response.nfts.map(res => nftFromGetNftCollectionResponse(res, contractAddress)),\n      pageKey: response.nextToken\n    };\n  });\n}\nfunction getOwnersForNft(alchemy, contractAddressOrNft, tokenId) {\n  if (typeof contractAddressOrNft === 'string') {\n    return requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getOwnersForToken', {\n      contractAddress: contractAddressOrNft,\n      tokenId: BigNumber.from(tokenId).toString()\n    });\n  } else {\n    return requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getOwnersForToken', {\n      contractAddress: contractAddressOrNft.contract.address,\n      tokenId: BigNumber.from(contractAddressOrNft.tokenId).toString()\n    });\n  }\n}\nfunction getOwnersForCollection(alchemy, contractAddressOrNft) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let response;\n    if (typeof contractAddressOrNft === 'string') {\n      response = yield requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getOwnersForCollection', {\n        contractAddress: contractAddressOrNft\n      });\n    } else {\n      response = yield requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getOwnersForCollection', {\n        contractAddress: contractAddressOrNft.contract.address\n      });\n    }\n    return {\n      owners: response.ownerAddresses\n    };\n  });\n}\nfunction getNftsForCollectionIterator(alchemy, contractAddress, options) {\n  return __asyncGenerator(this, arguments, function* getNftsForCollectionIterator_1() {\n    var e_2, _a;\n    const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n    try {\n      for (var _b = __asyncValues(paginateEndpoint(alchemy, AlchemyApiType.NFT, 'getNFTsForCollection', 'startToken', 'nextToken', {\n          contractAddress,\n          startToken: options === null || options === void 0 ? void 0 : options.pageKey,\n          withMetadata\n        })), _c; _c = yield __await(_b.next()), !_c.done;) {\n        const response = _c.value;\n        for (const nft of response.nfts) {\n          yield yield __await(nftFromGetNftCollectionResponse(nft, contractAddress));\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  });\n}\n/**\r\n * Checks that the provided owner address owns one of more of the provided NFTs.\r\n *\r\n * @param alchemy - The Alchemy SDK instance.\r\n * @param owner - The owner address to check.\r\n * @param contractAddresses - An array of NFT contract addresses to check ownership for.\r\n * @beta\r\n */\nfunction checkNftOwnership(alchemy, owner, contractAddresses) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (contractAddresses.length === 0) {\n      throw new Error('Must provide at least one contract address');\n    }\n    const response = yield getNftsForOwner(alchemy, owner, {\n      contractAddresses,\n      omitMetadata: true\n    });\n    return response.ownedNfts.length > 0;\n  });\n}\n/**\r\n * Returns whether a contract is marked as spam or not by Alchemy. For more\r\n * information on how we classify spam, go to our NFT API FAQ at\r\n * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\r\n *\r\n * @param alchemy - The Alchemy SDK instance.\r\n * @param contractAddress - The contract address to check.\r\n * @beta\r\n */\nfunction isSpamNftContract(alchemy, contractAddress) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'isSpamContract', {\n      contractAddress\n    });\n  });\n}\n/**\r\n * Returns a list of all spam contracts marked by Alchemy. For details on how\r\n * Alchemy marks spam contracts, go to\r\n * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\r\n *\r\n * @param alchemy - The Alchemy SDK instance.\r\n * @beta\r\n */\nfunction getSpamNftContracts(alchemy) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getSpamContracts', undefined);\n  });\n}\n/**\r\n * Returns the floor prices of a NFT contract by marketplace.\r\n *\r\n * @param alchemy - The Alchemy SDK instance.\r\n * @param contractAddress - The contract address for the NFT collection.\r\n * @beta\r\n */\nfunction getNftFloorPrice(alchemy, contractAddress) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getFloorPrice', {\n      contractAddress\n    });\n  });\n}\n/**\r\n * Finds the address that deployed the provided contract and block number it was\r\n * deployed in.\r\n *\r\n * NOTE: This method performs a binary search across all blocks since genesis\r\n * and can take a long time to complete. This method is a convenience method\r\n * that will eventually be replaced by a single call to an Alchemy endpoint with\r\n * this information cached.\r\n *\r\n * @param alchemy - The Alchemy SDK instance.\r\n * @param contractAddress - The contract address to find the deployer for.\r\n * @beta\r\n */\nfunction findContractDeployer(alchemy, contractAddress) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    const provider = alchemy.getProvider();\n    const currentBlockNum = yield provider.getBlockNumber();\n    if ((yield provider.getCode(contractAddress, currentBlockNum)) === ETH_NULL_VALUE) {\n      throw new Error(`Contract '${contractAddress}' does not exist`);\n    }\n    // Binary search for the block number that the contract was deployed in.\n    const firstBlock = yield binarySearchFirstBlock(0, currentBlockNum + 1, contractAddress, alchemy);\n    // Find the first transaction in the block that matches the provided address.\n    const txReceipts = yield getTransactionReceipts(alchemy, {\n      blockNumber: toHex(firstBlock)\n    });\n    const matchingReceipt = (_a = txReceipts.receipts) === null || _a === void 0 ? void 0 : _a.find(receipt => receipt.contractAddress === contractAddress.toLowerCase());\n    return {\n      deployerAddress: matchingReceipt === null || matchingReceipt === void 0 ? void 0 : matchingReceipt.from,\n      blockNumber: firstBlock\n    };\n  });\n}\nfunction refreshNftMetadata(alchemy, contractAddressOrBaseNft, tokenId) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let contractAddress;\n    let tokenIdString;\n    if (typeof contractAddressOrBaseNft === 'string') {\n      contractAddress = contractAddressOrBaseNft;\n      tokenIdString = BigNumber.from(tokenId).toString();\n    } else {\n      contractAddress = contractAddressOrBaseNft.contract.address;\n      tokenIdString = contractAddressOrBaseNft.tokenId;\n    }\n    const first = yield getNftMetadata(alchemy, contractAddress, tokenIdString);\n    const second = yield refresh(alchemy, contractAddress, tokenIdString);\n    return first.timeLastUpdated !== second.timeLastUpdated;\n  });\n}\nfunction refresh(alchemy, contractAddress, tokenId) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const response = yield requestHttpWithBackoff(alchemy, AlchemyApiType.NFT, 'getNFTMetadata', {\n      contractAddress,\n      tokenId: BigNumber.from(tokenId).toString(),\n      refreshCache: true\n    });\n    return getNftFromRaw(response, contractAddress);\n  });\n}\n/**\r\n * Perform a binary search between an integer range of block numbers to find the\r\n * block number where the contract was deployed.\r\n *\r\n * @internal\r\n */\nfunction binarySearchFirstBlock(start, end, address, alchemy) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (start >= end) {\n      return end;\n    }\n    const mid = Math.floor((start + end) / 2);\n    const code = yield alchemy.getProvider().getCode(address, mid);\n    if (code === ETH_NULL_VALUE) {\n      return binarySearchFirstBlock(mid + 1, end, address, alchemy);\n    }\n    return binarySearchFirstBlock(start, mid, address, alchemy);\n  });\n}\n/**\r\n * Helper method to convert a NFT response received from Alchemy backend to an\r\n * SDK NFT type.\r\n *\r\n * @internal\r\n */\nfunction nftFromGetNftResponse(ownedNft) {\n  if (isNftWithMetadata(ownedNft)) {\n    return getNftFromRaw(ownedNft, ownedNft.contract.address);\n  } else {\n    return getBaseNftFromRaw(ownedNft, ownedNft.contract.address);\n  }\n}\n/**\r\n * Helper method to convert a NFT response received from Alchemy backend to an\r\n * SDK NFT type.\r\n *\r\n * @internal\r\n */\nfunction nftFromGetNftCollectionResponse(ownedNft, contractAddress) {\n  if (isNftWithMetadata(ownedNft)) {\n    return getNftFromRaw(ownedNft, contractAddress);\n  } else {\n    return getBaseNftFromRaw(ownedNft, contractAddress);\n  }\n}\n/** @internal */\n// TODO: more comprehensive type check\nfunction isNftWithMetadata(response) {\n  return response.title !== undefined;\n}\n/**\r\n * Flips the `omitMetadata` SDK parameter type to the `withMetadata` parameter\r\n * required by the Alchemy API. If `omitMetadata` is undefined, the SDK defaults\r\n * to including metadata.\r\n *\r\n * @internal\r\n */\nfunction omitMetadataToWithMetadata(omitMetadata) {\n  return omitMetadata === undefined ? true : !omitMetadata;\n}\nexport { Alchemy, AlchemyProvider, AlchemyWebSocketProvider, AssetTransfersCategory, AssetTransfersOrder, Network, NftExcludeFilters, NftTokenType, checkNftOwnership, findContractDeployer, fromHex, getAssetTransfers, getNftContractMetadata, getNftFloorPrice, getNftMetadata, getNftsForCollection, getNftsForCollectionIterator, getNftsForOwner, getNftsForOwnerIterator, getOwnersForCollection, getOwnersForNft, getSpamNftContracts, getTokenBalances, getTokenMetadata, getTransactionReceipts, initializeAlchemy, isHex, isSpamNftContract, refreshNftMetadata, setLogLevel, toHex };","map":{"version":3,"mappings":"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","names":["Network","AssetTransfersCategory","AssetTransfersOrder","NftTokenType","NftExcludeFilters","DEFAULT_CONTRACT_ADDRESSES","DEFAULT_ALCHEMY_API_KEY","DEFAULT_NETWORK","ETH_MAINNET","DEFAULT_MAX_RETRIES","network","apiKey","AlchemyApiType","EthersNetwork","ETH_ROPSTEN","ETH_GOERLI","ETH_KOVAN","ETH_RINKEBY","OPT_MAINNET","OPT_KOVAN","ARB_MAINNET","ARB_RINKEBY","MATIC_MAINNET","MATIC_MUMBAI","noop","LogLevel","logLevelStringToEnum","debug","DEBUG","info","INFO","warn","WARN","error","ERROR","silent","SILENT","logLevelToConsoleFn","DEFAULT_LOG_LEVEL","setLogLevel","logLevel","loggerClient","logDebug","message","args","logInfo","logWarn","Logger","constructor","_logLevel","val","TypeError","_log","now","Date","toISOString","method","console","map","stringify","Error","obj","JSON","e","VERSION","AlchemyProvider","JsonRpcProvider","maxRetries","getApiKey","alchemyNetwork","getAlchemyNetwork","connection","getAlchemyConnectionInfo","ethersNetwork","undefined","isValidNetwork","Object","values","includes","join","type","url","getAlchemyHttpUrl","getAlchemyWsUrl","headers","allowGzip","detectNetwork","_super","_startPending","isCommunityResource","send","params","fromHex","hexString","BigNumber","from","toNumber","toHex","num","toHexString","isHex","possibleHexString","test","MAX_BACKFILL_BLOCKS","WebsocketBackfiller","provider","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","throwIfCancelled","toBlockNumber","getBlockNumber","length","getHeadEventsInRange","Math","max","maxBackfillBlocks","lastSeenBlockNumber","number","minBlockNumber","reorgHeads","getReorgHeads","intermediateHeads","getLogsBackfill","filter","previousLogs","getLogsInRange","blockNumber","commonAncestor","getCommonAncestor","removedLogs","log","removed","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","setMaxBackfillBlock","newMax","blockNumberHex","toBlockExclusive","batchParts","i","push","batchedBlockHeads","sendBatch","blockHeads","reduce","acc","batch","concat","toNewHeadsEvent","result","oldEvent","blockHead","getBlockByNumber","hash","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","dedupeNewHeads","events","dedupe","event","dedupeLogs","items","getKey","keysSeen","Set","forEach","item","key","has","add","CANCELLED","Event","tag","listener","once","_lastBlockNumber","_inflight","split","comps","address","topics","deserializeTopics","pollable","PollableEvents","indexOf","EthersEvent","data","topic","HEARTBEAT_INTERVAL","HEARTBEAT_WAIT_TIME","BACKFILL_TIMEOUT","BACKFILL_RETRIES","RETAINED_EVENT_BLOCK_COUNT","AlchemyWebSocketProvider","WebSocketProvider","wsConstructor","protocol","ws","SturdyWebSocket","getWebsocketConstructor","Map","parse","isSubscriptionEvent","physicalId","subscription","virtualId","virtualIdsByPhysicalId","get","virtualSubscriptionsById","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","addToNewHeadsEventsBuffer","emitAndRememberEvent","getNewHeadsBlockNumber","rememberEvent","logsSubscription","logsMessage","addToLogsEventsBuffer","getLogsBlockNumber","clear","cancel","makeCancelToken","cancelBackfill","__awaiter","resubscribeAndBackfill","startHeartbeat","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","on","eventName","_addEventListener","isAlchemyEvent","getAlchemyEventTag","_events","_startEvent","customLogicTypes","customStartEvent","_subscribe","param","processFunc","subIdPromise","_subIds","startingBlockNumber","Promise","all","then","subId","resolvedParams","set","sentEvents","_subs","emit","stopped","eventTag","setTimeout","apply","_stopEvent","parts","nextId","payload","jsonrpc","id","response","sendBatchConcurrently","errorResponse","find","r","sort","r1","r2","destroy","removeSocketListeners","stopHeartbeatAndBackfill","_websocket","addEventListener","handleMessage","handleReopen","removeEventListener","backfillEvents","withBackoffRetries","withTimeout","emitNewHeadsEvent","emitLogsEvent","emitGenericEvent","addToPastEventsBuffer","emitFunction","emitProcessFn","setInterval","_a","reconnect","req","_getFilter","_emitted","block","formatter","filterLog","isNodeEnvironment","require","w3cwebsocket","WebSocket","process","versions","node","cancelled","MIN_RETRY_DELAY","RETRY_BACKOFF_FACTOR","MAX_RETRY_DELAY","f","retryCount","shouldRetry","nextWaitTime","delay","min","ms","resolve","promise","race","_","reject","isResponse","Array","isArray","pastEvents","currentBlockNumber","firstGoodIndex","findIndex","splice","initializeAlchemy","config","Alchemy","getBaseUrl","getNftUrl","getAlchemyNftHttpUrl","setNetwork","getProvider","_baseAlchemyProvider","getWebsocketProvider","_baseAlchemyWssProvider","IS_BROWSER","window","sendAxiosRequest","baseUrl","methodName","methodUrl","axios","DEFAULT_BACKOFF_INITIAL_DELAY_MS","DEFAULT_BACKOFF_MULTIPLIER","DEFAULT_BACKOFF_MAX_DELAY_MS","DEFAULT_BACKOFF_MAX_ATTEMPTS","ExponentialBackoff","maxAttempts","backoff","numAttempts","isInBackoff","backoffDelayWithJitterMs","withJitterMs","currentDelayMs","backoffMultiplier","initialDelayMs","maxDelayMs","delayMs","random","requestHttpWithBackoff","alchemy","apiType","lastError","attempt","err","NFT","BASE","status","isAxiosError","isRetryableHttpError","retryableCodes","reqPageKey","resPageKey","hasNext","requestParams","__await","formatBlock","isInteger","toString","getNftContractFromRaw","rawNftContract","name","contractMetadata","symbol","totalSupply","tokenType","parseNftTokenType","rawBaseNft","contractAddress","contract","tokenId","tokenMetadata","rawNft","parseNftTokenId","title","description","parseNftDescription","timeLastUpdated","metadataError","rawMetadata","metadata","tokenUri","parseNftTokenUri","media","parseNftTokenUriArray","ERC721","ERC1155","UNKNOWN","uri","raw","gateway","arr","getTokenBalances","contractAddresses","maxCount","ETH_NULL_VALUE","getNftMetadata","contractAddressOrBaseNft","getNftFromRaw","contractAddressOrBaseNftContract","getNftsForOwnerIterator","owner","options","withMetadata","omitMetadataToWithMetadata","omitMetadata","pageKey","filters","excludeFilters","ownedNft","ownedNfts","nftFromGetNftResponse","balance","parseInt","getNftsForOwner","res","totalCount","getNftsForCollection","startToken","nfts","nftFromGetNftCollectionResponse","nextToken","getOwnersForNft","contractAddressOrNft","owners","ownerAddresses","getNftsForCollectionIterator","nft","checkNftOwnership","getSpamNftContracts","currentBlockNum","getCode","firstBlock","binarySearchFirstBlock","txReceipts","getTransactionReceipts","matchingReceipt","receipts","receipt","toLowerCase","deployerAddress","refreshNftMetadata","tokenIdString","first","second","refresh","refreshCache","start","end","mid","floor","code","isNftWithMetadata","getBaseNftFromRaw"],"sources":["/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/types/types.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/util/const.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/util/logger.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/version.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/api/alchemy-provider.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/api/util.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/internal/websocket-backfiller.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/internal/internal-types.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/api/alchemy-websocket-provider.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/api/alchemy.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/util/sendRest.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/internal/backoff.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/internal/dispatch.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/util/util.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/api/enhanced.ts","/Users/mehmetkelnebioglu/Desktop/untitled folder/node_modules/@alch/alchemy-sdk/src/api/nft-api.ts"],"sourcesContent":["import {\n  EventType,\n  TransactionReceipt\n} from '@ethersproject/abstract-provider';\nimport { BaseNft, Nft } from '../api/nft';\n\n// TODO: separate this file into other files.\n\n/**\n * Options object used to configure the Alchemy SDK.\n *\n * @public\n */\nexport interface AlchemyConfig {\n  /** The Alchemy API key that can be found in the Alchemy dashboard. */\n  apiKey?: string;\n\n  /** The name of the network. */\n  network?: Network;\n\n  /** The maximum number of retries to attempt if a request fails. Defaults to 5. */\n  maxRetries?: number;\n}\n\n/**\n * The supported networks by Alchemy. Note that some functions are not available\n * on all networks. Please refer to the Alchemy documentation for more details.\n *\n * @public\n */\nexport enum Network {\n  ETH_MAINNET = 'eth-mainnet',\n  ETH_ROPSTEN = 'eth-ropsten',\n  ETH_GOERLI = 'eth-goerli',\n  ETH_KOVAN = 'eth-kovan',\n  ETH_RINKEBY = 'eth-rinkeby',\n  OPT_MAINNET = 'opt-mainnet',\n  OPT_KOVAN = 'opt-kovan',\n  ARB_MAINNET = 'arb-mainnet',\n  ARB_RINKEBY = 'arb-rinkeby',\n  MATIC_MAINNET = 'polygon-mainnet',\n  MATIC_MUMBAI = 'polygon-mumbai'\n}\n\n/** @public */\nexport interface TokenBalancesResponse {\n  address: string;\n  tokenBalances: TokenBalance[];\n}\n\n/** @public */\nexport type TokenBalance = TokenBalanceSuccess | TokenBalanceFailure;\n\n/** @public */\nexport interface TokenBalanceSuccess {\n  contractAddress: string;\n  tokenBalance: string;\n  error: null;\n}\n\n/** @public */\nexport interface TokenBalanceFailure {\n  contractAddress: string;\n  tokenBalance: null;\n  error: string;\n}\n\n/** @public */\nexport interface TokenMetadataResponse {\n  decimals: number | null;\n  logo: string | null;\n  name: string | null;\n  symbol: string | null;\n}\n\n/** @public */\nexport interface AssetTransfersParams {\n  fromBlock?: string;\n  toBlock?: string;\n  order?: AssetTransfersOrder;\n  fromAddress?: string;\n  toAddress?: string;\n  contractAddresses?: string[];\n  excludeZeroValue?: boolean;\n  maxCount?: number;\n  category: AssetTransfersCategory[];\n  pageKey?: string;\n}\n\n/** @public */\nexport enum AssetTransfersCategory {\n  EXTERNAL = 'external',\n  INTERNAL = 'internal',\n  TOKEN = 'token',\n  ERC20 = 'erc20',\n  ERC721 = 'erc721',\n  ERC1155 = 'erc1155',\n\n  /**\n   * Special contracts that don't follow ERC 721/1155, (ex: CryptoKitties).\n   *\n   * @beta\n   */\n  SPECIALNFT = 'specialnft'\n}\n\n/** @public */\nexport enum AssetTransfersOrder {\n  ASCENDING = 'asc',\n  DESCENDING = 'desc'\n}\n\n/** @public */\nexport enum NftTokenType {\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155',\n  UNKNOWN = 'UNKNOWN'\n}\n\n/** @public */\nexport interface AssetTransfersResponse {\n  transfers: AssetTransfersResult[];\n  pageKey?: string;\n}\n\n/** @public */\nexport interface AssetTransfersResult {\n  category: AssetTransfersCategory;\n  blockNum: string;\n  from: string;\n  to: string | null;\n  value: number | null;\n  erc721TokenId: string | null;\n  erc1155Metadata: ERC1155Metadata[] | null;\n  tokenId: string | null;\n  asset: string | null;\n  hash: string;\n  rawContract: RawContract;\n}\n\n/**\n * Represents NFT metadata that holds fields. Note that since there is no\n * standard metadata format, the fields are not guaranteed to be present.\n *\n * @public\n */\nexport interface NftMetadata extends Record<string, any> {\n  /** Name of the NFT asset. */\n  name?: string;\n\n  /** A human-readable description of the NFT asset. */\n  description?: string;\n\n  /** URL to the NFT asset image. */\n  image?: string;\n\n  /**\n   * The image URL that appears along the top of the NFT asset page. This tends\n   * to be the highest resolution image.\n   */\n  external_url?: string;\n\n  /** Background color of the NFT item. Usually defined as a 6 character hex string. */\n  background_color?: string;\n\n  /** The traits, attributes, and characteristics for the NFT asset. */\n  attributes?: Array<Record<string, any>>;\n}\n\n/** @public */\nexport interface TokenUri {\n  /** URI for the location of the NFT's original metadata blob. */\n  raw: string;\n  /** Public gateway URI for the raw URI. Generally offers better performance. */\n  gateway: string;\n}\n\n/**\n * Optional parameters object for the {@link getNftsForOwner} and\n * {@link getNftsForOwnerIterator} functions.\n *\n * This interface is used to fetch NFTs with their associated metadata. To get\n * Nfts without their associated metadata, use {@link GetBaseNftsForOwnerOptions}.\n *\n * @public\n */\nexport interface GetNftsForOwnerOptions {\n  /**\n   * Optional page key from an existing {@link OwnedBaseNftsResponse} or\n   * {@link OwnedNftsResponse}to use for pagination.\n   */\n  pageKey?: string;\n\n  /** Optional list of contract addresses to filter the results by. Limit is 20. */\n  contractAddresses?: string[];\n\n  /**\n   * Optional list of filters applied to the query. NFTs that match one or more\n   * of these filters are excluded from the response.\n   */\n  excludeFilters?: NftExcludeFilters[];\n\n  /** Optional boolean flag to omit NFT metadata. Defaults to `false`. */\n  omitMetadata?: boolean;\n}\n\n/**\n * Optional parameters object for the {@link getNftsForOwner} and\n * {@link getNftsForOwnerIterator} functions.\n *\n * This interface is used to fetch NFTs without their associated metadata. To\n * get Nfts with their associated metadata, use {@link GetNftsForOwnerOptions}.\n *\n * @public\n */\nexport interface GetBaseNftsForOwnerOptions {\n  /**\n   * Optional page key from an existing {@link OwnedBaseNftsResponse} or\n   * {@link OwnedNftsResponse}to use for pagination.\n   */\n  pageKey?: string;\n\n  /** Optional list of contract addresses to filter the results by. Limit is 20. */\n  contractAddresses?: string[];\n\n  /**\n   * Optional list of filters applied to the query. NFTs that match one or more\n   * of these filters are excluded from the response.\n   */\n  excludeFilters?: NftExcludeFilters[];\n\n  /** Optional boolean flag to include NFT metadata. Defaults to `false`. */\n  omitMetadata: true;\n}\n\n/**\n * Enum of NFT filters that can be applied to a {@link getNftsForOwner} request.\n * NFTs that match one or more of these filters are excluded from the response.\n *\n * @beta\n */\nexport enum NftExcludeFilters {\n  /** Exclude NFTs that have been classified as spam. */\n  SPAM = 'SPAM'\n}\n\n/**\n * The response object for the {@link getNftsForOwner} and\n * {@link getNftsForOwnerIterator} functions. The object contains the NFTs with\n * metadata owned by the provided address, along with pagination information and\n * the total count.\n *\n * @public\n */\nexport interface OwnedNftsResponse {\n  /** The NFTs owned by the provided address. */\n  readonly ownedNfts: OwnedNft[];\n\n  /**\n   * Pagination token that can be passed into another request to fetch the next\n   * NFTs. If there is no page key, then there are no more NFTs to fetch.\n   */\n  readonly pageKey?: string;\n\n  /** The total count of NFTs owned by the provided address. */\n  readonly totalCount: number;\n}\n\n/**\n * The response object for the {@link getNftsForOwner} and\n * {@link getNftsForOwnerIterator)} functions. The object contains the NFTs\n * without metadata owned by the provided address, along with pagination\n * information and the total count.\n *\n * @public\n */\nexport interface OwnedBaseNftsResponse {\n  /** The NFTs owned by the provided address. */\n  readonly ownedNfts: OwnedBaseNft[];\n\n  /**\n   * Pagination token that can be passed into another request to fetch the next\n   * NFTs. If there is no page key, then there are no more NFTs to fetch.\n   */\n  readonly pageKey?: string;\n\n  /** The total count of NFTs owned by the provided address. */\n  readonly totalCount: number;\n}\n\n/**\n * Represents an NFT with metadata owned by an address.\n *\n * @public\n */\nexport interface OwnedNft extends Nft {\n  /** The token balance of the NFT. */\n  readonly balance: number;\n}\n\n/**\n * Represents an NFT without metadata owned by an address.\n *\n * @public\n */\nexport interface OwnedBaseNft extends BaseNft {\n  /** The token balance of the NFT. */\n  readonly balance: number;\n}\n\n/**\n * The response object for the {@link getOwnersForNft}.\n *\n * @public\n */\nexport interface GetOwnersForNftResponse {\n  /** An array of owner addresses for the provided token. */\n  readonly owners: string[];\n}\n\n/**\n * The response object for the {@link getOwnersForCollection}.\n *\n * @public\n */\nexport interface GetOwnersForCollectionResponse {\n  /** An array of owner addresses for the provided contract address */\n  readonly owners: string[];\n}\n\n/**\n * The successful object returned by the {@link getNftFloorPrice} call for each\n * marketplace (e.g. looksRare).\n *\n * @public\n */\nexport interface FloorPriceMarketplace {\n  /** The floor price of the collection on the given marketplace */\n  readonly floorPrice: number;\n  /** The currency in which the floor price is denominated */\n  readonly priceCurrency: string;\n  /** The link to the collection on the given marketplace */\n  readonly collectionUrl: string;\n  /** UTC timestamp of when the floor price was retrieved from the marketplace */\n  readonly retrievedAt: string;\n}\n\n/**\n * The failing object returned by the {@link getNftFloorPrice} call for each\n * marketplace (e.g. looksRare).\n *\n * @public\n */\nexport interface FloorPriceError {\n  /** Error fetching floor prices from the given marketplace */\n  readonly error: string;\n}\n\n/**\n * The response object for the {@link getNftFloorPrice} method.\n *\n * @public\n */\nexport interface GetNftFloorPriceResponse {\n  /**\n   * Name of the NFT marketplace where the collection is listed. Current\n   * marketplaces supported: OpenSea, LooksRare\n   */\n  readonly openSea: FloorPriceMarketplace | FloorPriceError;\n  readonly looksRare: FloorPriceMarketplace | FloorPriceError;\n}\n\n/** @public */\nexport interface TransactionReceiptsBlockNumber {\n  blockNumber: string;\n}\n\n/** @public */\nexport interface TransactionReceiptsBlockHash {\n  blockHash: string;\n}\n\n/** @public */\nexport type TransactionReceiptsParams =\n  | TransactionReceiptsBlockNumber\n  | TransactionReceiptsBlockHash;\n\n/** @public */\nexport interface TransactionReceiptsResponse {\n  receipts: TransactionReceipt[] | null;\n}\n\n/** @public */\nexport interface ERC1155Metadata {\n  tokenId: string;\n  value: string;\n}\n\n/** @public */\nexport interface RawContract {\n  value: string | null;\n  address: string | null;\n  decimal: string | null;\n}\n\n/**\n * Optional parameters object for the {@link getNftsForCollection} and\n * {@link getNftsForCollectionIterator} functions.\n *\n * This interface is used to fetch NFTs with their associated metadata. To get\n * Nfts without their associated metadata, use {@link GetBaseNftsForCollectionOptions}.\n *\n * @public\n */\nexport interface GetNftsForCollectionOptions {\n  /**\n   * Optional page key from an existing {@link CollectionBaseNftsResponse} or\n   * {@link CollectionNftsResponse}to use for pagination.\n   */\n  pageKey?: string;\n\n  /** Optional boolean flag to omit NFT metadata. Defaults to `false`. */\n  omitMetadata?: boolean;\n}\n\n/**\n * Optional parameters object for the {@link getNftsForCollection} and\n * {@link getNftsForCollectionIterator} functions.\n *\n * This interface is used to fetch NFTs without their associated metadata. To\n * get Nfts with their associated metadata, use {@link GetNftsForCollectionOptions}.\n *\n * @public\n */\nexport interface GetBaseNftsForCollectionOptions {\n  /**\n   * Optional page key from an existing {@link CollectionBaseNftsResponse} or\n   * {@link CollectionNftsResponse}to use for pagination.\n   */\n  pageKey?: string;\n\n  /** Optional boolean flag to omit NFT metadata. Defaults to `false`. */\n  omitMetadata: false;\n}\n\n/**\n * The response object for the {@link getNftsForCollection} function. The object\n * contains the NFTs without metadata inside the collection.\n *\n * @public\n */\nexport interface CollectionBaseNftsResponse {\n  /** An array of NFTs without metadata. */\n  nfts: BaseNft[];\n\n  /**\n   * Pagination token that can be passed into another request to fetch the next\n   * NFTs. If there is no page key, then there are no more NFTs to fetch.\n   */\n  pageKey?: string;\n}\n\n/**\n * The response object for the {@link getNftsForCollection} function. The object\n * contains the NFTs with metadata inside the collection.\n *\n * @public\n */\nexport interface CollectionNftsResponse {\n  /** An array of NFTs with metadata. */\n  nfts: Nft[];\n\n  /**\n   * Pagination token that can be passed into another request to fetch the next\n   * NFTs. If there is no page key, then there are no more NFTs to fetch.\n   */\n  pageKey?: string;\n}\n\n/**\n * The response object for the {@link findContractDeployer} function.\n *\n * @public\n */\nexport interface DeployResult {\n  /** The address of the contract deployer, if it is available. */\n  readonly deployerAddress?: string;\n\n  /** The block number the contract was deployed in. */\n  readonly blockNumber: number;\n}\n\n/**\n * Event filters for the {@link AlchemyWebSocketProvider.on} method to use\n * Alchemy's custom Subscription API endpoints.\n *\n * @public\n */\nexport type AlchemyEventFilter =\n  | {\n      method: 'alchemy_newFullPendingTransactions';\n    }\n  | {\n      method: 'alchemy_filteredNewFullPendingTransactions';\n      address: string;\n    };\n\n/**\n * Alchemy's event filter that extends the default {@link EventType} interface to\n * also include Alchemy's Subscription API.\n *\n * @public\n */\nexport type AlchemyEventType = EventType | AlchemyEventFilter;\n","import { Network } from '../types/types';\n\nexport const DEFAULT_CONTRACT_ADDRESSES = 'DEFAULT_TOKENS';\nexport const DEFAULT_ALCHEMY_API_KEY = 'demo';\nexport const DEFAULT_NETWORK = Network.ETH_MAINNET;\nexport const DEFAULT_MAX_RETRIES = 5;\n\n/**\n * Returns the base URL for making Alchemy API requests. The `alchemy.com`\n * endpoints only work with non eth json-rpc requests.\n *\n * @internal\n */\nexport function getAlchemyHttpUrl(network: Network, apiKey: string): string {\n  return `https://${network}.g.alchemy.com/v2/${apiKey}`;\n}\n\nexport function getAlchemyNftHttpUrl(network: Network, apiKey: string): string {\n  return `https://${network}.g.alchemy.com/nft/v2/${apiKey}`;\n}\n\nexport function getAlchemyWsUrl(network: Network, apiKey: string): string {\n  return `wss://${network}.g.alchemy.com/v2/${apiKey}`;\n}\n\nexport enum AlchemyApiType {\n  BASE,\n  NFT\n}\n\n/**\n * Mapping of network names to their corresponding Network strings used to\n * create an Ethers.js Provider instance.\n */\nexport const EthersNetwork = {\n  [Network.ETH_MAINNET]: 'mainnet',\n  [Network.ETH_ROPSTEN]: 'ropsten',\n  [Network.ETH_GOERLI]: 'goerli',\n  [Network.ETH_KOVAN]: 'kovan',\n  [Network.ETH_RINKEBY]: 'rinkeby',\n  [Network.OPT_MAINNET]: 'optimism',\n  [Network.OPT_KOVAN]: 'optimism-kovan',\n  [Network.ARB_MAINNET]: 'arbitrum',\n  [Network.ARB_RINKEBY]: 'arbitrum-rinkeby',\n  [Network.MATIC_MAINNET]: 'matic',\n  [Network.MATIC_MUMBAI]: 'maticmum'\n};\n\nexport function noop(): void {\n  // It's a no-op\n}\n","/**\n * The SDK has 4 log levels and a 5th option for disabling all logging. By\n * default, the log level is set to INFO.\n *\n * The order is a follows: DEBUG < INFO < WARN < ERROR\n *\n * All log types above the current log level will be outputted.\n */\nexport enum LogLevel {\n  DEBUG,\n  INFO,\n  WARN,\n  ERROR,\n  SILENT\n}\n\n/**\n * The level of verbosity for the logger.\n *\n * @public\n */\nexport type LogLevelString = 'debug' | 'info' | 'warn' | 'error' | 'silent';\n\nconst logLevelStringToEnum: { [key in LogLevelString]: LogLevel } = {\n  debug: LogLevel.DEBUG,\n  info: LogLevel.INFO,\n  warn: LogLevel.WARN,\n  error: LogLevel.ERROR,\n  silent: LogLevel.SILENT\n};\n\n// HACKY: Use the console method as a string rather than the function itself\n// in order to allow for mocking in tests.\nconst logLevelToConsoleFn = {\n  [LogLevel.DEBUG]: 'log',\n  [LogLevel.INFO]: 'info',\n  [LogLevel.WARN]: 'warn',\n  [LogLevel.ERROR]: 'error'\n};\n\nconst DEFAULT_LOG_LEVEL = LogLevel.INFO;\n\n/**\n * Configures the verbosity of logging. The default log level is `info`.\n *\n * @param logLevel - The verbosity of logging. Can be any of the following values:\n *\n *   - `debug`: The most verbose logging level.\n *   - `info`: The default logging level.\n *   - `warn`: A logging level for non-critical issues.\n *   - `error`: A logging level for critical issues.\n *   - `silent`: Turn off all logging.\n *\n * @public\n */\nexport function setLogLevel(logLevel: LogLevelString): void {\n  loggerClient.logLevel = logLevelStringToEnum[logLevel];\n}\n\nexport function logDebug(message: string, ...args: unknown[]): void {\n  loggerClient.debug(message, args);\n}\n\nexport function logInfo(message: string, ...args: unknown[]): void {\n  loggerClient.info(message, args);\n}\n\nexport function logWarn(message: string, ...args: unknown[]): void {\n  loggerClient.warn(message, args);\n}\n\nexport function logError(message: string, ...args: unknown[]): void {\n  loggerClient.error(message, args);\n}\n\nexport class Logger {\n  /** The log level of the given Logger instance. */\n  private _logLevel = DEFAULT_LOG_LEVEL;\n\n  constructor() {}\n\n  get logLevel(): LogLevel {\n    return this._logLevel;\n  }\n\n  set logLevel(val: LogLevel) {\n    if (!(val in LogLevel)) {\n      throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n    }\n    this._logLevel = val;\n  }\n\n  debug(...args: unknown[]): void {\n    this._log(LogLevel.DEBUG, ...args);\n  }\n\n  info(...args: unknown[]): void {\n    this._log(LogLevel.INFO, ...args);\n  }\n\n  warn(...args: unknown[]): void {\n    this._log(LogLevel.WARN, ...args);\n  }\n\n  error(...args: unknown[]): void {\n    this._log(LogLevel.ERROR, ...args);\n  }\n\n  /**\n   * Forwards log messages to their corresponding console counterparts if the\n   * log level allows it.\n   */\n  private _log(logLevel: LogLevel, ...args: unknown[]): void {\n    if (logLevel < this._logLevel) {\n      return;\n    }\n    const now = new Date().toISOString();\n    const method =\n      logLevelToConsoleFn[logLevel as keyof typeof logLevelToConsoleFn];\n    if (method) {\n      console[method as 'log' | 'info' | 'warn' | 'error'](\n        `[${now}] Alchemy:`,\n        ...args.map(stringify)\n      );\n    } else {\n      throw new Error(\n        `Logger received an invalid logLevel (value: ${logLevel})`\n      );\n    }\n  }\n}\n\nfunction stringify(obj: unknown): string | unknown {\n  if (typeof obj === 'string') {\n    return obj;\n  } else {\n    try {\n      return JSON.stringify(obj);\n    } catch (e) {\n      // Failed to convert to JSON, log the object directly.\n      return obj;\n    }\n  }\n}\n\n// Instantiate default logger for the SDK.\nconst loggerClient: Logger = new Logger();\n","// This file is autogenerated by injectVersion.js. Any changes will be\n// overwritten on commit!\nexport const VERSION = '1.1.1';\n","import {\n  JsonRpcProvider,\n  CommunityResourcable\n} from '@ethersproject/providers';\nimport {\n  Network as NetworkFromEthers,\n  Networkish\n} from '@ethersproject/networks';\nimport { ConnectionInfo } from '@ethersproject/web';\nimport {\n  DEFAULT_ALCHEMY_API_KEY,\n  DEFAULT_NETWORK,\n  EthersNetwork,\n  getAlchemyHttpUrl,\n  getAlchemyWsUrl\n} from '../util/const';\nimport { Network } from '../types/types';\nimport { logWarn } from '../util/logger';\nimport { VERSION } from '../version';\n\n/**\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\n *\n * @public\n */\nexport class AlchemyProvider\n  extends JsonRpcProvider\n  implements CommunityResourcable\n{\n  readonly apiKey: string;\n  readonly maxRetries: number;\n\n  constructor(network: Networkish, apiKey: string, maxRetries: number) {\n    // Normalize the API Key to a string.\n    apiKey = AlchemyProvider.getApiKey(apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'http'\n    );\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(connection, ethersNetwork);\n    this.apiKey = apiKey;\n    this.maxRetries = maxRetries;\n  }\n\n  /**\n   * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\n   * ethers.js. Returns the API key for an Alchemy provider.\n   *\n   * @internal\n   * @override\n   */\n  static getApiKey(apiKey: any): string {\n    if (apiKey == null) {\n      return DEFAULT_ALCHEMY_API_KEY;\n    }\n    if (apiKey && typeof apiKey !== 'string') {\n      throw new Error(\n        `Invalid apiKey '${apiKey}' provided. apiKey must be a string.`\n      );\n    }\n    return apiKey;\n  }\n\n  /**\n   * Converts the `Networkish` input to the network enum used by Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyNetwork(network?: Networkish): Network {\n    if (network === undefined) {\n      return DEFAULT_NETWORK;\n    }\n\n    if (typeof network === 'number') {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be a string.`\n      );\n    }\n\n    // Guaranteed that `typeof network === 'string`.\n    const isValidNetwork = Object.values(Network).includes(network as Network);\n    if (!isValidNetwork) {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be one of: ` +\n          `${Object.values(Network).join(', ')}.`\n      );\n    }\n    return network as Network;\n  }\n\n  /**\n   * Returns a {@link ConnectionInfo} object compatible with ethers that contains\n   * the correct URLs for Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyConnectionInfo(\n    network: Network,\n    apiKey: string,\n    type: 'wss' | 'http'\n  ): ConnectionInfo {\n    const url =\n      type === 'http'\n        ? getAlchemyHttpUrl(network, apiKey)\n        : getAlchemyWsUrl(network, apiKey);\n    return {\n      headers: {\n        'Alchemy-Ethers-Sdk-Version': VERSION,\n        'Accept-Encoding': 'gzip'\n      },\n      allowGzip: true,\n      url\n    };\n  }\n\n  /**\n   * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\n   * method is called when calling methods on the parent class `BaseProvider`.\n   *\n   * @override\n   */\n  async detectNetwork(): Promise<NetworkFromEthers> {\n    let network = this.network;\n    if (network == null) {\n      network = await super.detectNetwork();\n\n      if (!network) {\n        throw new Error('No network detected');\n      }\n    }\n    return network;\n  }\n\n  _startPending(): void {\n    logWarn('WARNING: Alchemy Provider does not support pending filters');\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * Overrides the base {@link JsonRpcProvider.send} method to implement custom\n   * logic for sending requests to Alchemy.\n   *\n   * @param method The method name to use for the request.\n   * @param params The parameters to use for the request.\n   * @override\n   * @public\n   */\n  // TODO: Implement sender logic to override retries and backoff.\n  send(method: string, params: Array<any>): Promise<any> {\n    return super.send(method, params);\n  }\n}\n","import { BigNumber } from '@ethersproject/bignumber';\n\n/**\n * Converts a hex string to a decimal number.\n *\n * @param hexString - The hex string to convert.\n * @public\n */\nexport function fromHex(hexString: string): number {\n  return BigNumber.from(hexString).toNumber();\n}\n\n/**\n * Converts a number to a hex string.\n *\n * @param num - The number to convert to hex.\n * @public\n */\nexport function toHex(num: number): string {\n  return BigNumber.from(num).toHexString();\n}\n\n/**\n * Checks if a value is a hex string.\n *\n * @param possibleHexString - The value to check.\n * @public\n */\nexport function isHex(possibleHexString: string): boolean {\n  return /^0x[0-9a-fA-F]+$/.test(possibleHexString);\n}\n","import { fromHex, toHex } from '../api/util';\nimport { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';\n\nexport interface BatchPart {\n  method: string;\n  params?: any;\n}\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/** The return type of eth_getBlocksByHash. */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\nexport interface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\ninterface CommonAncestor {\n  blockNumber: number;\n  logIndex: number;\n}\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The WebsocketBackfiller fetches events that were sent since a provided block\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\n * events that were transmitted while the websocket connection was down.\n *\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\n *\n * @internal\n */\nexport class WebsocketBackfiller {\n  // TODO: Use HTTP provider to do backfill.\n  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  constructor(private readonly provider: AlchemyWebSocketProvider) {}\n\n  /**\n   * Runs backfill for `newHeads` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param previousHeads Previous head requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   * @returns A list of `newHeads` events that were sent since the last backfill.\n   */\n  async getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous heads to fetch, return new heads since\n    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n    if (previousHeads.length === 0) {\n      return this.getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted event is too far back in the past, there's no need\n    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n    // new heads.\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber <= minBlockNumber) {\n      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n\n    // To capture all `newHeads` events, return all head events from the last\n    // seen block number to current + any of the previous heads that were re-orged.\n    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(\n      isCancelled,\n      previousHeads\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  /**\n   * Runs backfill for `logs` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param filter The filter object that accompanies a logs subscription.\n   * @param previousLogs Previous log requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   */\n  async getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous logs to fetch, return new logs since\n    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n    if (previousLogs.length === 0) {\n      return this.getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted log is too far back in the past, there's no need\n    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n    // worth of logs.\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n\n    // Return all log events that have happened along with log events that have\n    // been removed due to a chain reorg.\n    const commonAncestor = await this.getCommonAncestor(\n      isCancelled,\n      previousLogs\n    );\n    throwIfCancelled(isCancelled);\n\n    // All previous logs with a block number greater than the common ancestor\n    // were part of a re-org, so mark them as such.\n    const removedLogs = previousLogs\n      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\n      .map(log => ({ ...log, removed: true }));\n\n    // If no common ancestor was found, start backfill from the oldest log's\n    // block number.\n    const fromBlockInclusive =\n      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\n        ? fromHex(previousLogs[0].blockNumber)\n        : commonAncestor.blockNumber;\n    let addedLogs = await this.getLogsInRange(\n      filter,\n      fromBlockInclusive,\n      toBlockNumber + 1\n    );\n\n    // De-dupe any logs that were already emitted.\n    addedLogs = addedLogs.filter(\n      log =>\n        log &&\n        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\n          fromHex(log.logIndex) > commonAncestor.logIndex)\n    );\n\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  /**\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  setMaxBackfillBlock(newMax: number): void {\n    this.maxBackfillBlocks = newMax;\n  }\n\n  /**\n   * Gets the current block number as a number.\n   *\n   * @private\n   */\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.provider.send('eth_blockNumber');\n    return fromHex(blockNumberHex);\n  }\n\n  /**\n   * Gets all `newHead` events in the provided range. Note that the returned\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\n   * that were part of a re-org.\n   *\n   * @private\n   */\n  private async getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: 'eth_getBlockByNumber',\n        params: [toHex(i), false]\n      });\n    }\n\n    // TODO: just fire off each send() separately since we're no longer batching:\n    // TODO: handle errors\n    const batchedBlockHeads = await this.provider.sendBatch(batchParts);\n    const blockHeads = batchedBlockHeads.reduce(\n      (acc, batch) => acc.concat(batch),\n      []\n    );\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  /**\n   * Returns all heads that were part of a reorg event.\n   *\n   * @private\n   */\n  private async getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[]\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n\n      // If the hashes match, then current head in the iteration was not re-orged.\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  /**\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\n   * block information for the provided block number.\n   *\n   * @private\n   */\n  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return this.provider.send('eth_getBlockByNumber', [\n      toHex(blockNumber),\n      false\n    ]);\n  }\n\n  /**\n   * Given a list of previous log events, finds the common block number from the\n   * logs that matches the block head.\n   *\n   * This can be used to identify which logs are part of a re-org.\n   *\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\n   *\n   * @private\n   */\n  private async getCommonAncestor(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[]\n  ): Promise<CommonAncestor> {\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    let blockHead = await this.getBlockByNumber(\n      fromHex(previousLogs[previousLogs.length - 1].blockNumber)\n    );\n    throwIfCancelled(isCancelled);\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const oldLog = previousLogs[i];\n\n      // Ensure that updated blocks are fetched every time the log's block number\n      // changes.\n      if (oldLog.blockNumber !== blockHead.number) {\n        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));\n      }\n\n      // Since logs are ordered in ascending order, the first log that matches\n      // the hash should be the largest logIndex.\n      if (oldLog.blockHash === blockHead.hash) {\n        return {\n          blockNumber: fromHex(oldLog.blockNumber),\n          logIndex: fromHex(oldLog.logIndex)\n        };\n      }\n    }\n    return {\n      blockNumber: Number.NEGATIVE_INFINITY,\n      logIndex: Number.NEGATIVE_INFINITY\n    };\n  }\n\n  /**\n   * Gets all `logs` events in the provided range. Note that the returned logs\n   * do not include removed logs.\n   *\n   * @private\n   */ private async getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1)\n    };\n    return this.provider.send('eth_getLogs', [rangeFilter]);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, event => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst CANCELLED = new Error('Cancelled');\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n","import {\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent\n} from './websocket-backfiller';\nimport { EventType, Filter, Listener } from '@ethersproject/abstract-provider';\n\ntype JsonRpcId = string | number | null;\n\nexport interface JsonRpcRequest {\n  jsonrpc: '2.0';\n  method: string;\n  params?: any[];\n  id?: JsonRpcId;\n}\n\nexport interface VirtualSubscription {\n  event: EthersEvent;\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\nexport interface JsonRpcResponse<T = any> {\n  jsonrpc: '2.0';\n  result?: T;\n  error?: JsonRpcError;\n  id: JsonRpcId;\n}\n\ninterface JsonRpcError<T = any> {\n  code: number;\n  message: string;\n  data?: T;\n}\n\nexport interface NewHeadsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['newHeads'];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\nexport interface LogsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['logs', LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\nexport type WebSocketMessage = SingleOrBatchResponse | SubscriptionEvent;\nexport type SingleOrBatchResponse = JsonRpcResponse | JsonRpcResponse[];\n\n/**\n * DO NOT MODIFY.\n *\n * Event class copied directly over from ethers.js's `BaseProvider` class.\n *\n * This class is used to represent events and their corresponding listeners. The\n * SDK needs to extend this class in order to support Alchemy's custom\n * Subscription API types. The original class is not exported by ethers. Minimal\n * changes have been made in order to get TS to compile.\n */\nexport class Event {\n  readonly listener: Listener;\n  readonly once: boolean;\n  readonly tag: string;\n\n  _lastBlockNumber: number;\n  _inflight: boolean;\n\n  constructor(tag: string, listener: Listener, once: boolean) {\n    this.listener = listener;\n    this.tag = tag;\n    this.once = once;\n    this._lastBlockNumber = -2;\n    this._inflight = false;\n  }\n\n  get event(): EventType {\n    switch (this.type) {\n      case 'tx':\n        return this.hash!;\n      case 'filter':\n        return this.filter!;\n      default:\n        return this.tag;\n    }\n  }\n\n  get type(): string {\n    return this.tag.split(':')[0];\n  }\n\n  get hash(): string {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'tx') {\n      throw new Error('Not a transaction event');\n    }\n    return comps[1];\n  }\n\n  get filter(): Filter {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'filter') {\n      throw new Error('Not a transaction event');\n    }\n    const address = comps[1];\n\n    const topics = deserializeTopics(comps[2]);\n    const filter: Filter = {};\n\n    if (topics.length > 0) {\n      filter.topics = topics;\n    }\n    if (address && address !== '*') {\n      filter.address = address;\n    }\n\n    return filter;\n  }\n\n  pollable(): boolean {\n    const PollableEvents = ['block', 'network', 'pending', 'poll'];\n    return this.tag.indexOf(':') >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n  }\n}\n\n/**\n * Wrapper class around the ethers `Event` class in order to add support for\n * Alchemy's custom subscriptions types.\n */\nexport class EthersEvent extends Event {\n  get address(): string | null {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'alchemy') {\n      return null;\n    }\n    if (comps[1] && comps[1] !== '*') {\n      return comps[1];\n    } else {\n      return null;\n    }\n  }\n}\n\nexport interface SubscriptionEvent<T = any> {\n  jsonrpc: '2.0';\n  method: 'eth_subscription';\n  params: {\n    subscription: string;\n    result: T;\n  };\n}\n\nfunction deserializeTopics(data: string): any {\n  if (data === '') {\n    return [];\n  }\n\n  return data.split(/&/g).map(topic => {\n    if (topic === '') {\n      return [];\n    }\n\n    const comps = topic.split('|').map(topic => {\n      return topic === 'null' ? null : topic;\n    });\n\n    return comps.length === 1 ? comps[0] : comps;\n  });\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { Networkish } from '@ethersproject/networks';\nimport { DEFAULT_ALCHEMY_API_KEY, EthersNetwork, noop } from '../util/const';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { Listener } from '@ethersproject/abstract-provider';\nimport { AlchemyEventType } from '../types/types';\nimport {\n  BatchPart,\n  dedupeLogs,\n  dedupeNewHeads,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent,\n  throwIfCancelled,\n  WebsocketBackfiller\n} from '../internal/websocket-backfiller';\nimport { fromHex } from './util';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { VERSION } from '../version';\nimport {\n  EthersEvent,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  LogsSubscription,\n  NewHeadsSubscription,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  VirtualSubscription,\n  WebSocketMessage\n} from '../internal/internal-types';\nimport {\n  CommunityResourcable,\n  WebSocketProvider\n} from '@ethersproject/providers';\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\nexport class AlchemyWebSocketProvider\n  extends WebSocketProvider\n  implements CommunityResourcable\n{\n  _events: Array<EthersEvent> = [];\n  readonly apiKey: string;\n\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  /** @internal */\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  /** @internal */\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  /** @internal */\n  private readonly backfiller: WebsocketBackfiller;\n  /** @internal */\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  /** @internal */\n  private cancelBackfill: () => void;\n\n  /**\n   * DO NOT CALL THIS CONSTRUCTOR DIRECTLY. Instead, use `Alchemy.getWebsocketProvider()`.\n   *\n   * @param network Requires one of the Alchemy `Network` enums\n   * @param apiKey The api key, or defaults to `demo`.\n   * @param wsConstructor Optional WebSocket constructor. Currently, used only\n   *   for testing purposes.\n   * @internal\n   */\n  constructor(network?: Networkish, apiKey?: any, wsConstructor?: any) {\n    // Normalize the API Key to a string.\n    apiKey = AlchemyProvider.getApiKey(apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'wss'\n    );\n\n    const protocol = `alchemy-sdk-${VERSION}`;\n    const ws = new SturdyWebSocket(connection.url, protocol, {\n      wsConstructor: wsConstructor ?? getWebsocketConstructor()\n    });\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws as any, ethersNetwork);\n    this.apiKey = apiKey;\n\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n\n  /**\n   * Overridden implementation of ethers' that includes Alchemy based subscriptions.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  /**\n   * Overrides the method in `BaseProvider` in order to properly format the\n   * Alchemy subscription events.\n   *\n   * @internal\n   * @override\n   */\n  _addEventListener(\n    eventName: AlchemyEventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    if (isAlchemyEvent(eventName)) {\n      const event = new EthersEvent(\n        getAlchemyEventTag(eventName),\n        listener,\n        once\n      );\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n\n  /**\n   * Overrides the `_startEvent()` method in ethers.js's\n   * {@link WebSocketProvider} to include additional alchemy methods.\n   *\n   * @param event\n   * @override\n   * @internal\n   */\n  _startEvent(event: EthersEvent): void {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = ['alchemy', 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n\n  /**\n   * Overridden from ethers.js's {@link WebSocketProvider}\n   *\n   * Modified in order to add mappings for backfilling.\n   *\n   * @internal\n   * @override\n   */\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void,\n    event?: EthersEvent\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n\n    // BEGIN MODIFIED CODE\n    const startingBlockNumber = await this.getBlockNumber();\n    // END MODIFIED CODE\n\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then(param => {\n        return this.send('eth_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n\n    // BEGIN MODIFIED CODE\n    const resolvedParams = await Promise.all(param);\n    this.virtualSubscriptionsById.set(subId, {\n      event: event!,\n      method: 'eth_subscribe',\n      params: resolvedParams,\n      startingBlockNumber,\n      virtualId: subId,\n      physicalId: subId,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: []\n    });\n    this.virtualIdsByPhysicalId.set(subId, subId);\n\n    // END MODIFIED CODE\n\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @internal\n   * @override\n   */\n  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n\n      const stopped: Array<EthersEvent> = [];\n\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n\n        result = true;\n\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n\n        return true;\n      });\n\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n\n  /** @internal */\n  async sendBatch(parts: BatchPart[]): Promise<any[]> {\n    let nextId = 0;\n    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {\n      return {\n        method,\n        params,\n        jsonrpc: '2.0',\n        id: `alchemy-sdk:${nextId++}`\n      };\n    });\n\n    const response = await this.sendBatchConcurrently(payload);\n    const errorResponse = response.find(r => !!r.error);\n    if (errorResponse) {\n      throw new Error(errorResponse.error!.message);\n    }\n    // The ids are ascending numbers because that's what Payload Factories do.\n    return response\n      .sort((r1, r2) => (r1.id as number) - (r2.id as number))\n      .map(r => r.result);\n  }\n\n  /** @override */\n  destroy(): Promise<void> {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /** @internal */\n  private addSocketListeners(): void {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /** @internal */\n  private removeSocketListeners(): void {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /**\n   * The underlying ethers {@link WebSocketProvider} already handles and emits\n   * messages. To allow backfilling, track all messages that are emitted.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== 'eth_subscribe') {\n      return;\n    }\n\n    switch (subscription.params[0]) {\n      case 'newHeads': {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        } else {\n          // Ethers subscription mapping will emit the event, just store it.\n          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        }\n        break;\n      }\n      case 'logs': {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else if (virtualId !== physicalId) {\n          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n        } else {\n          this.rememberEvent(virtualId, result, getLogsBlockNumber);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  /**\n   * When the websocket connection reopens:\n   *\n   * 1. Resubscribe to all existing subscriptions and start backfilling\n   * 2. Restart heart beat.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleReopen = () => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      void (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  /**\n   * Reopens the backfill based on\n   *\n   * @param isCancelled\n   * @param subscription\n   * @internal\n   */\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case 'newHeads': {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case 'logs': {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n  /**\n   * Cancels the heartbeat and any pending backfills being performed. This is\n   * called when the websocket connection goes down or is disconnected.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private stopHeartbeatAndBackfill = () => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  /** @internal */\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  /** @internal */\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   *\n   * @internal\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n\n  /** @internal */\n  private rememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber\n    );\n  }\n\n  /** @internal */\n  private emitGenericEvent(\n    subscription: VirtualSubscription,\n    result: any\n  ): void {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n\n  /**\n   * Starts a heartbeat that pings the websocket server periodically to ensure\n   * that the connection stays open.\n   *\n   * @internal\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this._websocket.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * This method sends the batch concurrently as individual requests rather than\n   * as a batch, which was the original implementation. The original batch logic\n   * is preserved in this implementation in order for faster porting.\n   *\n   * @param payload\n   * @internal\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  private async sendBatchConcurrently(\n    payload: JsonRpcRequest[]\n  ): Promise<JsonRpcResponse[]> {\n    return Promise.all(payload.map(req => this.send(req.method, req.params)));\n  }\n\n  /** @internal */\n  private customStartEvent(event: EthersEvent): void {\n    if (event.type === 'alchemy') {\n      const { address } = event;\n      if (!!address) {\n        void this._subscribe(\n          event.tag,\n          ['alchemy_filteredNewFullPendingTransactions', { address }],\n          this.emitProcessFn(event),\n          event\n        );\n      } else {\n        void this._subscribe(\n          event.tag,\n          ['alchemy_newFullPendingTransactions'],\n          this.emitProcessFn(event),\n          event\n        );\n      }\n    } else if (event.type === 'block') {\n      void this._subscribe(\n        'block',\n        ['newHeads'],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'filter') {\n      void this._subscribe(\n        event.tag,\n        ['logs', this._getFilter(event.filter)],\n        this.emitProcessFn(event),\n        event\n      );\n    }\n  }\n\n  /** @internal */\n  private emitProcessFn(event: EthersEvent): (result: any) => void {\n    switch (event.type) {\n      case 'alchemy':\n        const { address } = event;\n        if (!!address) {\n          return result =>\n            this.emit(\n              {\n                method: 'alchemy_filteredNewFullPendingTransactions',\n                address: event.address!\n              },\n              result\n            );\n        } else {\n          return result =>\n            this.emit({ method: 'alchemy_newFullPendingTransactions' }, result);\n        }\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n}\n\nfunction getWebsocketConstructor(): any {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\n\nfunction isNodeEnvironment(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/** @internal */\ninterface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\nasync function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction isResponse(\n  message: WebSocketMessage\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nfunction isSubscriptionEvent(\n  message: WebSocketMessage\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which are so old\n * that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n\nfunction isAlchemyEvent(event: AlchemyEventType): event is object {\n  return typeof event === 'object' && 'method' in event;\n}\n\nfunction getAlchemyEventTag(event: AlchemyEventType): string {\n  if (!isAlchemyEvent(event)) {\n    throw new Error('Event tag requires AlchemyEventType');\n  }\n  return 'alchemy:' + (('address' in event && event.address) || '*');\n}\n","import { AlchemyConfig, Network } from '../types/types';\nimport {\n  DEFAULT_ALCHEMY_API_KEY,\n  DEFAULT_MAX_RETRIES,\n  DEFAULT_NETWORK,\n  getAlchemyHttpUrl,\n  getAlchemyNftHttpUrl\n} from '../util/const';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { AlchemyWebSocketProvider } from './alchemy-websocket-provider';\n\n/**\n * Entry point into the Alchemy SDK.\n *\n * @param config - Configuration object for the Alchemy SDK\n * @public\n */\nexport function initializeAlchemy(config?: AlchemyConfig): Alchemy {\n  return new Alchemy(config);\n}\n\n/**\n * The Alchemy SDK client. This class holds config information and must be\n * passed into SDK methods.\n *\n * Do not call this constructor directly. Instead, use {@link initializeAlchemy}\n * to get an instance of the SDK.\n *\n * @public\n */\nexport class Alchemy {\n  readonly apiKey: string;\n  network: Network;\n  readonly maxRetries: number;\n\n  /** @internal */\n  private _baseAlchemyProvider: AlchemyProvider | undefined;\n\n  /** @internal */\n  private _baseAlchemyWssProvider: AlchemyWebSocketProvider | undefined;\n\n  /**\n   * @hideconstructor\n   * @internal\n   */\n  constructor(config?: AlchemyConfig) {\n    this.apiKey = config?.apiKey || DEFAULT_ALCHEMY_API_KEY;\n    this.network = config?.network || DEFAULT_NETWORK;\n    this.maxRetries = config?.maxRetries || DEFAULT_MAX_RETRIES;\n  }\n\n  /** @internal */\n  getBaseUrl(): string {\n    return getAlchemyHttpUrl(this.network, this.apiKey);\n  }\n\n  /** @internal */\n  getNftUrl(): string {\n    return getAlchemyNftHttpUrl(this.network, this.apiKey);\n  }\n\n  /**\n   * Changes the network that the SDK requests data from.\n   *\n   * @param network - The network to change to.\n   * @public\n   */\n  setNetwork(network: Network) {\n    // TODO(ethers): Add support for changing the network in the returned provider.\n    this.network = network;\n  }\n\n  /**\n   * Creates an AlchemyProvider instance. Only one provider is created per\n   * Alchemy instance.\n   *\n   * @public\n   */\n  getProvider(): AlchemyProvider {\n    if (!this._baseAlchemyProvider) {\n      this._baseAlchemyProvider = new AlchemyProvider(\n        this.network,\n        this.apiKey,\n        this.maxRetries\n      );\n    }\n    return this._baseAlchemyProvider;\n  }\n\n  /**\n   * Creates an AlchemyWebsocketProvider instance. Only one provider is created\n   * per Alchemy instance.\n   *\n   * @public\n   */\n  getWebsocketProvider(): AlchemyWebSocketProvider {\n    if (!this._baseAlchemyWssProvider) {\n      this._baseAlchemyWssProvider = new AlchemyWebSocketProvider(\n        this.network,\n        this.apiKey\n      );\n    }\n    return this._baseAlchemyWssProvider;\n  }\n}\n","/**\n * Given a REST endpoint, method, and params, sends the request with axios and\n * returns the response.\n */\nimport axios, { AxiosRequestConfig, AxiosResponse } from 'axios';\nimport { VERSION } from '../version';\n\nconst IS_BROWSER = typeof window !== 'undefined' && window !== null;\n\n/**\n * Helper function to send http requests using Axis.\n *\n * @private\n */\n// TODO: Support other methods besides GET + other http options.\nexport function sendAxiosRequest<Req, Res>(\n  baseUrl: string,\n  methodName: string,\n  params: Req\n): Promise<AxiosResponse<Res>> {\n  const methodUrl = baseUrl + '/' + methodName;\n  const config: AxiosRequestConfig = {\n    headers: IS_BROWSER\n      ? {\n          'Alchemy-Ethers-Sdk-Version': VERSION\n        }\n      : {\n          'Alchemy-Ethers-Sdk-Version': VERSION,\n          'Accept-Encoding': 'gzip'\n        },\n    method: 'get',\n    url: methodUrl,\n    params\n  };\n  return axios(config);\n}\n","import { logDebug } from '../util/logger';\n\nexport const DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\nexport const DEFAULT_BACKOFF_MULTIPLIER = 1.5;\nexport const DEFAULT_BACKOFF_MAX_DELAY_MS = 30 * 1000;\nexport const DEFAULT_BACKOFF_MAX_ATTEMPTS = 5;\n\n/**\n * Helper class for implementing exponential backoff and max retry attempts.\n *\n * @private\n * @internal\n */\nexport class ExponentialBackoff {\n  private readonly initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n  private readonly backoffMultiplier = DEFAULT_BACKOFF_MULTIPLIER;\n  private readonly maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS;\n\n  private numAttempts = 0;\n  private currentDelayMs = 0;\n  private isInBackoff = false;\n\n  constructor(private readonly maxAttempts = DEFAULT_BACKOFF_MAX_ATTEMPTS) {}\n\n  /**\n   * Returns a promise that resolves after the the backoff delay. The delay is\n   * increased for each attempt. The promise is rejected if the maximum number\n   * of attempts is exceeded.\n   */\n  // TODO: beautify this into an async iterator.\n  backoff(): Promise<void> {\n    if (this.numAttempts >= this.maxAttempts) {\n      return Promise.reject(\n        new Error(`Exceeded maximum number of attempts: ${this.maxAttempts}`)\n      );\n    }\n    if (this.isInBackoff) {\n      return Promise.reject(\n        new Error('A backoff operation is already in progress')\n      );\n    }\n\n    const backoffDelayWithJitterMs = this.withJitterMs(this.currentDelayMs);\n    if (backoffDelayWithJitterMs > 0) {\n      logDebug(\n        'ExponentialBackoff.backoff',\n        `Backing off for ${backoffDelayWithJitterMs}ms`\n      );\n    }\n\n    // Calculate the next delay.\n    this.currentDelayMs *= this.backoffMultiplier;\n    this.currentDelayMs = Math.max(this.currentDelayMs, this.initialDelayMs);\n    this.currentDelayMs = Math.min(this.currentDelayMs, this.maxDelayMs);\n    this.numAttempts += 1;\n\n    return new Promise(resolve => {\n      this.isInBackoff = true;\n      setTimeout(() => {\n        this.isInBackoff = false;\n        resolve();\n      }, backoffDelayWithJitterMs);\n    });\n  }\n\n  /**\n   * Applies +/- 50% jitter to the backoff delay, up to the max delay cap.\n   *\n   * @private\n   * @param delayMs\n   */\n  private withJitterMs(delayMs: number): number {\n    return Math.min(delayMs + (Math.random() - 0.5) * delayMs, this.maxDelayMs);\n  }\n}\n","import { Alchemy } from '../api/alchemy';\nimport { sendAxiosRequest } from '../util/sendRest';\nimport { ExponentialBackoff } from './backoff';\nimport axios, { AxiosError } from 'axios';\nimport { logDebug, logInfo } from '../util/logger';\nimport { AlchemyApiType } from '../util/const';\n\n/**\n * A wrapper function to make http requests and retry if the request fails.\n *\n * @param alchemy\n * @param method\n * @param params\n * @internal\n */\n// TODO: Wrap Axios error in AlchemyError.\nexport async function requestHttpWithBackoff<Req, Res>(\n  alchemy: Alchemy,\n  apiType: AlchemyApiType,\n  method: string,\n  params: Req\n): Promise<Res> {\n  let lastError: Error | undefined = undefined;\n  const backoff = new ExponentialBackoff(alchemy.maxRetries);\n  for (let attempt = 0; attempt < alchemy.maxRetries + 1; attempt++) {\n    try {\n      if (lastError !== undefined) {\n        logInfo('requestHttp', `Retrying after error: ${lastError.message}`);\n      }\n\n      try {\n        await backoff.backoff();\n      } catch (err) {\n        // Backoff errors when the maximum number of attempts is reached. Break\n        // out of the loop to preserve the last error.\n        break;\n      }\n\n      let response;\n      switch (apiType) {\n        case AlchemyApiType.NFT:\n          response = await sendAxiosRequest<Req, Res>(\n            alchemy.getNftUrl(),\n            method,\n            params\n          );\n          break;\n        default:\n        case AlchemyApiType.BASE:\n          response = await sendAxiosRequest<Req, Res>(\n            alchemy.getBaseUrl(),\n            method,\n            params\n          );\n          break;\n      }\n\n      if (response.status === 200) {\n        logDebug(method, `Successful request: ${method}`);\n        return response.data;\n      } else {\n        logInfo(\n          method,\n          `Request failed: ${method}, ${response.status}, ${response.data}`\n        );\n        lastError = new Error(response.status + ': ' + response.data);\n      }\n    } catch (err) {\n      if (!axios.isAxiosError(err) || err.response === undefined) {\n        throw err;\n      }\n      // TODO: Standardize all errors into AlchemyError\n      lastError = new Error(err.response.status + ': ' + err.response.data);\n      if (!isRetryableHttpError(err)) {\n        break;\n      }\n    }\n  }\n  return Promise.reject(lastError);\n}\n\nfunction isRetryableHttpError(err: AxiosError): boolean {\n  const retryableCodes = [429];\n  return (\n    err.response !== undefined && retryableCodes.includes(err.response.status)\n  );\n}\n\n/**\n * Fetches all pages in a paginated endpoint, given a `pageKey` field that\n * represents the property name containing the next page token.\n *\n * @internal\n */\nexport async function* paginateEndpoint<\n  ReqPageKey extends string,\n  ResPageKey extends string,\n  Req extends Partial<Record<string, any> & Record<ReqPageKey, string>>,\n  Res extends Partial<Record<string, any> & Record<ResPageKey, string>>\n>(\n  alchemy: Alchemy,\n  apiType: AlchemyApiType,\n  methodName: string,\n  reqPageKey: ReqPageKey,\n  resPageKey: ResPageKey,\n  params: Req\n): AsyncIterable<Res> {\n  let hasNext = true;\n  const requestParams = { ...params };\n  while (hasNext) {\n    const response = await requestHttpWithBackoff<Req, Res>(\n      alchemy,\n      apiType,\n      methodName,\n      requestParams\n    );\n    yield response;\n    if (response[resPageKey] !== undefined) {\n      requestParams[reqPageKey] = response[resPageKey] as any;\n    } else {\n      hasNext = false;\n    }\n  }\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { BaseNft, BaseNftContract, Nft, NftContract } from '../api/nft';\nimport { toHex } from '../api/util';\nimport {\n  RawBaseNft,\n  RawBaseNftContract,\n  RawNft,\n  RawNftContract\n} from '../internal/raw-interfaces';\nimport { NftTokenType, TokenUri } from '../types/types';\n\nexport function formatBlock(block: string | number): string {\n  if (typeof block === 'string') {\n    return block;\n  } else if (Number.isInteger(block)) {\n    return toHex(block);\n  }\n  return block.toString();\n}\n\nexport function getBaseNftContractFromRaw(\n  rawBaseNftContract: RawBaseNftContract\n): BaseNftContract {\n  return { address: rawBaseNftContract.address };\n}\n\nexport function getNftContractFromRaw(\n  rawNftContract: RawNftContract\n): NftContract {\n  return {\n    address: rawNftContract.address,\n    name: rawNftContract.contractMetadata.name,\n    symbol: rawNftContract.contractMetadata.symbol,\n    totalSupply: rawNftContract.contractMetadata.totalSupply,\n    tokenType: parseNftTokenType(rawNftContract.contractMetadata.tokenType)\n  };\n}\n\nexport function getBaseNftFromRaw(\n  rawBaseNft: RawBaseNft,\n  contractAddress: string\n): BaseNft {\n  return {\n    contract: { address: contractAddress },\n    tokenId: BigNumber.from(rawBaseNft.id.tokenId).toString(),\n    tokenType: parseNftTokenType(rawBaseNft.id.tokenMetadata?.tokenType)\n  };\n}\n\nexport function getNftFromRaw(rawNft: RawNft, contractAddress: string): Nft {\n  return {\n    contract: { address: contractAddress },\n    tokenId: parseNftTokenId(rawNft.id.tokenId),\n    tokenType: parseNftTokenType(rawNft.id.tokenMetadata?.tokenType),\n    title: rawNft.title,\n    description: parseNftDescription(rawNft.description),\n    timeLastUpdated: rawNft.timeLastUpdated,\n    metadataError: rawNft.error,\n    rawMetadata: rawNft.metadata,\n    tokenUri: parseNftTokenUri(rawNft.tokenUri),\n    media: parseNftTokenUriArray(rawNft.media)\n  };\n}\n\nfunction parseNftTokenId(tokenId: string): string {\n  // We have to normalize the token id here since the backend sometimes\n  // returns the token ID as a hex string and sometimes as an integer.\n  return BigNumber.from(tokenId).toString();\n}\n\nfunction parseNftTokenType(tokenType: string | undefined): NftTokenType {\n  switch (tokenType) {\n    case 'erc721':\n    case 'ERC721':\n      return NftTokenType.ERC721;\n    case 'erc1155':\n    case 'ERC1155':\n      return NftTokenType.ERC1155;\n    default:\n      return NftTokenType.UNKNOWN;\n  }\n}\n\nfunction parseNftDescription(description?: string | string[]): string {\n  if (description === undefined) {\n    return '';\n  }\n  return typeof description === 'string' ? description : description.join(' ');\n}\n\nfunction parseNftTokenUri(uri: TokenUri | undefined): TokenUri | undefined {\n  if (uri && uri.raw.length === 0 && uri.gateway.length == 0) {\n    return undefined;\n  }\n  return uri;\n}\n\nfunction parseNftTokenUriArray(arr: TokenUri[] | undefined): TokenUri[] {\n  if (arr === undefined) {\n    return [];\n  }\n  return arr.filter(uri => parseNftTokenUri(uri) !== undefined);\n}\n","import {\n  AssetTransfersParams,\n  AssetTransfersResponse,\n  TokenBalancesResponse,\n  TokenMetadataResponse,\n  TransactionReceiptsParams,\n  TransactionReceiptsResponse\n} from '../types/types';\nimport { formatBlock } from '../util/util';\nimport { Alchemy } from './alchemy';\nimport { DEFAULT_CONTRACT_ADDRESSES } from '../util/const';\nimport { toHex } from './util';\n\n/** @public */\nexport function getTokenBalances(\n  alchemy: Alchemy,\n  address: string,\n  contractAddresses?: string[]\n): Promise<TokenBalancesResponse> {\n  if (contractAddresses && contractAddresses.length > 1500) {\n    throw new Error(\n      'You cannot pass in more than 1500 contract addresses to getTokenBalances()'\n    );\n  }\n  return alchemy\n    .getProvider()\n    .send('alchemy_getTokenBalances', [\n      address,\n      contractAddresses || DEFAULT_CONTRACT_ADDRESSES\n    ]);\n}\n\n/** @public */\nexport function getTokenMetadata(\n  alchemy: Alchemy,\n  address: string\n): Promise<TokenMetadataResponse> {\n  return alchemy.getProvider().send('alchemy_getTokenMetadata', [address]);\n}\n\n/** @public */\nexport function getAssetTransfers(\n  alchemy: Alchemy,\n  params: AssetTransfersParams\n): Promise<AssetTransfersResponse> {\n  return alchemy.getProvider().send('alchemy_getAssetTransfers', [\n    {\n      ...params,\n      fromBlock:\n        params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,\n      toBlock: params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n      maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n    }\n  ]);\n}\n\n/** @public */\nexport function getTransactionReceipts(\n  alchemy: Alchemy,\n  params: TransactionReceiptsParams\n): Promise<TransactionReceiptsResponse> {\n  return alchemy.getProvider().send('alchemy_getTransactionReceipts', [params]);\n}\n","import {\n  CollectionBaseNftsResponse,\n  CollectionNftsResponse,\n  DeployResult,\n  GetBaseNftsForCollectionOptions,\n  GetBaseNftsForOwnerOptions,\n  GetNftFloorPriceResponse,\n  GetNftsForCollectionOptions,\n  GetNftsForOwnerOptions,\n  GetOwnersForCollectionResponse,\n  GetOwnersForNftResponse,\n  NftTokenType,\n  OwnedBaseNft,\n  OwnedBaseNftsResponse,\n  OwnedNft,\n  OwnedNftsResponse\n} from '../types/types';\nimport { Alchemy } from './alchemy';\nimport { paginateEndpoint, requestHttpWithBackoff } from '../internal/dispatch';\nimport { BaseNft, BaseNftContract, Nft, NftContract } from './nft';\nimport {\n  RawBaseNft,\n  RawCollectionBaseNft,\n  RawCollectionNft,\n  RawGetBaseNftsForCollectionResponse,\n  RawGetBaseNftsResponse,\n  RawGetNftsForCollectionResponse,\n  RawGetNftsResponse,\n  RawGetOwnersForCollectionResponse,\n  RawNft,\n  RawNftContract,\n  RawOwnedBaseNft,\n  RawOwnedNft\n} from '../internal/raw-interfaces';\nimport { toHex } from './util';\nimport { getTransactionReceipts } from './enhanced';\nimport { AlchemyApiType } from '../util/const';\nimport {\n  getNftContractFromRaw,\n  getNftFromRaw,\n  getBaseNftFromRaw\n} from '../util/util';\nimport { BigNumber, BigNumberish } from '@ethersproject/bignumber';\n\nconst ETH_NULL_VALUE = '0x';\n\n/**\n * Get the NFT metadata associated with the provided parameters.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param contractAddress - The contract address of the NFT.\n * @param tokenId - Token id of the NFT.\n * @param tokenType - Optionally specify the type of token to speed up the query.\n * @public\n */\nexport function getNftMetadata(\n  alchemy: Alchemy,\n  contractAddress: string,\n  tokenId: BigNumberish,\n  tokenType?: NftTokenType\n): Promise<Nft>;\n\n/**\n * Get the NFT metadata associated with the provided Base NFT.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param baseNft - The base NFT object to be used for the request.\n * @public\n */\nexport function getNftMetadata(\n  alchemy: Alchemy,\n  baseNft: BaseNft\n): Promise<Nft>;\nexport async function getNftMetadata(\n  alchemy: Alchemy,\n  contractAddressOrBaseNft: string | BaseNft,\n  tokenId?: BigNumberish,\n  tokenType?: NftTokenType\n): Promise<Nft> {\n  let response;\n  let contractAddress: string;\n  if (typeof contractAddressOrBaseNft === 'string') {\n    contractAddress = contractAddressOrBaseNft;\n    response = await requestHttpWithBackoff<GetNftMetadataParams, RawNft>(\n      alchemy,\n      AlchemyApiType.NFT,\n      'getNFTMetadata',\n      {\n        contractAddress: contractAddressOrBaseNft,\n        tokenId: BigNumber.from(tokenId!).toString(),\n        tokenType: tokenType !== NftTokenType.UNKNOWN ? tokenType : undefined\n      }\n    );\n  } else {\n    contractAddress = contractAddressOrBaseNft.contract.address;\n    response = await requestHttpWithBackoff<GetNftMetadataParams, RawNft>(\n      alchemy,\n      AlchemyApiType.NFT,\n      'getNFTMetadata',\n      {\n        contractAddress: contractAddressOrBaseNft.contract.address,\n        tokenId: BigNumber.from(contractAddressOrBaseNft.tokenId).toString(),\n        tokenType:\n          contractAddressOrBaseNft.tokenType !== NftTokenType.UNKNOWN\n            ? contractAddressOrBaseNft.tokenType\n            : undefined\n      }\n    );\n  }\n  return getNftFromRaw(response, contractAddress);\n}\n\n/**\n * Get the NFT collection metadata associated with the provided parameters.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param contractAddress - The contract address of the NFT.\n * @public\n */\nexport function getNftContractMetadata(\n  alchemy: Alchemy,\n  contractAddress: string\n): Promise<NftContract>;\n\n/**\n * Get the NFT metadata associated with the provided Base NFT.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param baseNftContract - The base NFT contract object to be used for the request.\n * @public\n */\nexport function getNftContractMetadata(\n  alchemy: Alchemy,\n  baseNftContract: BaseNftContract\n): Promise<NftContract>;\nexport async function getNftContractMetadata(\n  alchemy: Alchemy,\n  contractAddressOrBaseNftContract: string | BaseNftContract\n): Promise<NftContract> {\n  let response;\n  if (typeof contractAddressOrBaseNftContract === 'string') {\n    response = await requestHttpWithBackoff<\n      GetNftContractMetadataParams,\n      RawNftContract\n    >(alchemy, AlchemyApiType.NFT, 'getContractMetadata', {\n      contractAddress: contractAddressOrBaseNftContract\n    });\n  } else {\n    response = await requestHttpWithBackoff<\n      GetNftContractMetadataParams,\n      RawNftContract\n    >(alchemy, AlchemyApiType.NFT, 'getContractMetadata', {\n      contractAddress: contractAddressOrBaseNftContract.address\n    });\n  }\n  return getNftContractFromRaw(response);\n}\n\n/**\n * Fetches all NFTs for a given owner and yields them in an async iterable.\n *\n * This method returns the full NFT for the owner and pages through all page\n * keys until all NFTs have been fetched.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param owner - The address of the owner.\n * @param options - The optional parameters to use for the request.\n * @public\n */\nexport function getNftsForOwnerIterator(\n  alchemy: Alchemy,\n  owner: string,\n  options?: GetNftsForOwnerOptions\n): AsyncIterable<OwnedNft>;\n\n/**\n * Fetches all NFTs for a given owner and yields them in an async iterable.\n *\n * This method returns the base NFTs that omit the associated metadata and pages\n * through all page keys until all NFTs have been fetched.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param owner - The address of the owner.\n * @param options - The optional parameters to use for the request.\n * @public\n */\nexport function getNftsForOwnerIterator(\n  alchemy: Alchemy,\n  owner: string,\n  options?: GetBaseNftsForOwnerOptions\n): AsyncIterable<OwnedBaseNft>;\n\nexport async function* getNftsForOwnerIterator(\n  alchemy: Alchemy,\n  owner: string,\n  options?: GetNftsForOwnerOptions | GetBaseNftsForOwnerOptions\n): AsyncIterable<OwnedBaseNft | OwnedNft> {\n  const withMetadata = omitMetadataToWithMetadata(options?.omitMetadata);\n  for await (const response of paginateEndpoint(\n    alchemy,\n    AlchemyApiType.NFT,\n    'getNFTs',\n    'pageKey',\n    'pageKey',\n    {\n      contractAddresses: options?.contractAddresses,\n      pageKey: options?.pageKey,\n      filters: options?.excludeFilters,\n      owner,\n      withMetadata\n    }\n  )) {\n    for (const ownedNft of response.ownedNfts as\n      | RawOwnedNft[]\n      | RawOwnedBaseNft[]) {\n      yield {\n        ...nftFromGetNftResponse(ownedNft),\n        balance: parseInt(ownedNft.balance)\n      };\n    }\n  }\n}\n\n/**\n * Get all NFTs for an owner.\n *\n * This method returns the full NFTs in the contract. To get all NFTs without\n * their associated metadata, use {@link GetBaseNftsForOwnerOptions}.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param owner - The address of the owner.\n * @param options - The optional parameters to use for the request.\n * @public\n */\nexport async function getNftsForOwner(\n  alchemy: Alchemy,\n  owner: string,\n  options?: GetNftsForOwnerOptions\n): Promise<OwnedNftsResponse>;\n\n/**\n * Get all base NFTs for an owner.\n *\n * This method returns the base NFTs that omit the associated metadata. To get\n * all NFTs with their associated metadata, use {@link GetNftsForOwnerOptions}.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param owner - The address of the owner.\n * @param options - The optional parameters to use for the request.\n * @public\n */\nexport async function getNftsForOwner(\n  alchemy: Alchemy,\n  owner: string,\n  options?: GetBaseNftsForOwnerOptions\n): Promise<OwnedBaseNftsResponse>;\n\nexport async function getNftsForOwner(\n  alchemy: Alchemy,\n  owner: string,\n  options?: GetNftsForOwnerOptions | GetBaseNftsForOwnerOptions\n): Promise<OwnedNftsResponse | OwnedBaseNftsResponse> {\n  const withMetadata = omitMetadataToWithMetadata(options?.omitMetadata);\n  const response = await requestHttpWithBackoff<\n    GetNftsAlchemyParams,\n    RawGetBaseNftsResponse | RawGetNftsResponse\n  >(alchemy, AlchemyApiType.NFT, 'getNFTs', {\n    contractAddresses: options?.contractAddresses,\n    pageKey: options?.pageKey,\n    filters: options?.excludeFilters,\n    owner,\n    withMetadata\n  });\n  return {\n    ownedNfts: response.ownedNfts.map(res => ({\n      ...nftFromGetNftResponse(res),\n      balance: parseInt(res.balance)\n    })),\n    pageKey: response.pageKey,\n    totalCount: response.totalCount\n  };\n}\n\n/**\n * Get all NFTs for a given contract address.\n *\n * This method returns the full NFTs in the contract. To get all NFTs without\n * their associated metadata, use {@link GetBaseNftsForCollectionOptions}.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param contractAddress - The contract address of the collection.\n * @param options - The parameters to use for the request. or\n *   {@link CollectionNftsResponse} response.\n * @beta\n */\nexport async function getNftsForCollection(\n  alchemy: Alchemy,\n  contractAddress: string,\n  options?: GetNftsForCollectionOptions\n): Promise<CollectionNftsResponse>;\n\n/**\n * Get all base NFTs for a given contract address.\n *\n * This method returns the base NFTs that omit the associated metadata. To get\n * all NFTs with their associated metadata, use {@link GetNftsForCollectionOptions}.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param contractAddress - The contract address of the collection.\n * @param options - The optional parameters to use for the request.\n * @beta\n */\nexport async function getNftsForCollection(\n  alchemy: Alchemy,\n  contractAddress: string,\n  options?: GetBaseNftsForCollectionOptions\n): Promise<CollectionBaseNftsResponse>;\n\nexport async function getNftsForCollection(\n  alchemy: Alchemy,\n  contractAddress: string,\n  options?: GetBaseNftsForCollectionOptions | GetNftsForCollectionOptions\n): Promise<CollectionNftsResponse | CollectionBaseNftsResponse> {\n  const withMetadata = omitMetadataToWithMetadata(options?.omitMetadata);\n  const response = await requestHttpWithBackoff<\n    GetNftsForCollectionAlchemyParams,\n    RawGetBaseNftsForCollectionResponse | RawGetNftsForCollectionResponse\n  >(alchemy, AlchemyApiType.NFT, 'getNFTsForCollection', {\n    contractAddress,\n    startToken: options?.pageKey,\n    withMetadata\n  });\n\n  return {\n    nfts: response.nfts.map(res =>\n      nftFromGetNftCollectionResponse(res, contractAddress)\n    ),\n    pageKey: response.nextToken\n  };\n}\n\n/**\n * Gets all the owners for a given NFT contract address and token ID.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param contractAddress - The NFT contract address.\n * @param tokenId - Token id of the NFT.\n * @beta\n */\nexport function getOwnersForNft(\n  alchemy: Alchemy,\n  contractAddress: string,\n  tokenId: BigNumberish\n): Promise<GetOwnersForNftResponse>;\n\n/**\n * Gets all the owners for a given NFT.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param nft - The NFT object to get the owners for.\n * @beta\n */\nexport function getOwnersForNft(\n  alchemy: Alchemy,\n  nft: BaseNft\n): Promise<GetOwnersForNftResponse>;\nexport function getOwnersForNft(\n  alchemy: Alchemy,\n  contractAddressOrNft: string | BaseNft,\n  tokenId?: BigNumberish\n): Promise<GetOwnersForNftResponse> {\n  if (typeof contractAddressOrNft === 'string') {\n    return requestHttpWithBackoff(\n      alchemy,\n      AlchemyApiType.NFT,\n      'getOwnersForToken',\n      {\n        contractAddress: contractAddressOrNft,\n        tokenId: BigNumber.from(tokenId!).toString()\n      }\n    );\n  } else {\n    return requestHttpWithBackoff(\n      alchemy,\n      AlchemyApiType.NFT,\n      'getOwnersForToken',\n      {\n        contractAddress: contractAddressOrNft.contract.address,\n        tokenId: BigNumber.from(contractAddressOrNft.tokenId).toString()\n      }\n    );\n  }\n}\n\n/**\n * Gets all the owners for a given NFT collection.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param contractAddress - The NFT collection to get the owners for.\n * @beta\n */\nexport function getOwnersForCollection(\n  alchemy: Alchemy,\n  contractAddress: string\n): Promise<GetOwnersForCollectionResponse>;\n\n/**\n * Gets all the owners for a given NFT collection.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param nft - The NFT to get the owners of the collection for.\n * @beta\n */\nexport function getOwnersForCollection(\n  alchemy: Alchemy,\n  nft: BaseNft\n): Promise<GetOwnersForCollectionResponse>;\nexport async function getOwnersForCollection(\n  alchemy: Alchemy,\n  contractAddressOrNft: string | BaseNft\n): Promise<GetOwnersForCollectionResponse> {\n  let response;\n  if (typeof contractAddressOrNft === 'string') {\n    response = await requestHttpWithBackoff<\n      GetOwnersForCollectionAlchemyParams,\n      RawGetOwnersForCollectionResponse\n    >(alchemy, AlchemyApiType.NFT, 'getOwnersForCollection', {\n      contractAddress: contractAddressOrNft\n    });\n  } else {\n    response = await requestHttpWithBackoff<\n      GetOwnersForCollectionAlchemyParams,\n      RawGetOwnersForCollectionResponse\n    >(alchemy, AlchemyApiType.NFT, 'getOwnersForCollection', {\n      contractAddress: contractAddressOrNft.contract.address\n    });\n  }\n\n  return {\n    owners: response.ownerAddresses\n  };\n}\n\n/**\n * Fetches all NFTs for a given contract address and yields them in an async iterable.\n *\n * This method returns the full NFTs in the contract and pages through all page\n * keys until all NFTs have been fetched. To get all NFTs without their\n * associated metadata, use {@link GetBaseNftsForCollectionOptions}.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param contractAddress - The contract address of the collection.\n * @param options - The optional parameters to use for the request.\n * @beta\n */\nexport function getNftsForCollectionIterator(\n  alchemy: Alchemy,\n  contractAddress: string,\n  options?: GetNftsForCollectionOptions\n): AsyncIterable<Nft>;\n\n/**\n * Fetches all base NFTs for a given contract address and yields them in an\n * async iterable.\n *\n * This method returns the base NFTs that omit the associated metadata and pages\n * through all page keys until all NFTs have been fetched. To get all NFTs with\n * their associated metadata, use {@link GetNftsForCollectionOptions}.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param contractAddress - The contract address of the collection.\n * @param options - The optional parameters to use for the request.\n * @beta\n */\nexport function getNftsForCollectionIterator(\n  alchemy: Alchemy,\n  contractAddress: string,\n  options?: GetBaseNftsForCollectionOptions\n): AsyncIterable<BaseNft>;\n\nexport async function* getNftsForCollectionIterator(\n  alchemy: Alchemy,\n  contractAddress: string,\n  options?: GetBaseNftsForCollectionOptions | GetNftsForCollectionOptions\n): AsyncIterable<BaseNft | Nft> {\n  const withMetadata = omitMetadataToWithMetadata(options?.omitMetadata);\n  for await (const response of paginateEndpoint(\n    alchemy,\n    AlchemyApiType.NFT,\n    'getNFTsForCollection',\n    'startToken',\n    'nextToken',\n    {\n      contractAddress,\n      startToken: options?.pageKey,\n      withMetadata\n    }\n  )) {\n    for (const nft of response.nfts as\n      | RawCollectionBaseNft[]\n      | RawCollectionNft[]) {\n      yield nftFromGetNftCollectionResponse(nft, contractAddress);\n    }\n  }\n}\n\n/**\n * Checks that the provided owner address owns one of more of the provided NFTs.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param owner - The owner address to check.\n * @param contractAddresses - An array of NFT contract addresses to check ownership for.\n * @beta\n */\nexport async function checkNftOwnership(\n  alchemy: Alchemy,\n  owner: string,\n  contractAddresses: string[]\n): Promise<boolean> {\n  if (contractAddresses.length === 0) {\n    throw new Error('Must provide at least one contract address');\n  }\n  const response = await getNftsForOwner(alchemy, owner, {\n    contractAddresses,\n    omitMetadata: true\n  });\n  return response.ownedNfts.length > 0;\n}\n\n/**\n * Returns whether a contract is marked as spam or not by Alchemy. For more\n * information on how we classify spam, go to our NFT API FAQ at\n * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param contractAddress - The contract address to check.\n * @beta\n */\nexport async function isSpamNftContract(\n  alchemy: Alchemy,\n  contractAddress: string\n): Promise<boolean> {\n  return requestHttpWithBackoff<IsSpamContractParams, boolean>(\n    alchemy,\n    AlchemyApiType.NFT,\n    'isSpamContract',\n    {\n      contractAddress\n    }\n  );\n}\n\n/**\n * Returns a list of all spam contracts marked by Alchemy. For details on how\n * Alchemy marks spam contracts, go to\n * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @beta\n */\nexport async function getSpamNftContracts(alchemy: Alchemy): Promise<string[]> {\n  return requestHttpWithBackoff<undefined, string[]>(\n    alchemy,\n    AlchemyApiType.NFT,\n    'getSpamContracts',\n    undefined\n  );\n}\n\n/**\n * Returns the floor prices of a NFT contract by marketplace.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param contractAddress - The contract address for the NFT collection.\n * @beta\n */\nexport async function getNftFloorPrice(\n  alchemy: Alchemy,\n  contractAddress: string\n): Promise<GetNftFloorPriceResponse> {\n  return requestHttpWithBackoff<GetFloorPriceParams, GetNftFloorPriceResponse>(\n    alchemy,\n    AlchemyApiType.NFT,\n    'getFloorPrice',\n    {\n      contractAddress\n    }\n  );\n}\n\n/**\n * Finds the address that deployed the provided contract and block number it was\n * deployed in.\n *\n * NOTE: This method performs a binary search across all blocks since genesis\n * and can take a long time to complete. This method is a convenience method\n * that will eventually be replaced by a single call to an Alchemy endpoint with\n * this information cached.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param contractAddress - The contract address to find the deployer for.\n * @beta\n */\nexport async function findContractDeployer(\n  alchemy: Alchemy,\n  contractAddress: string\n): Promise<DeployResult> {\n  const provider = alchemy.getProvider();\n  const currentBlockNum = await provider.getBlockNumber();\n  if (\n    (await provider.getCode(contractAddress, currentBlockNum)) ===\n    ETH_NULL_VALUE\n  ) {\n    throw new Error(`Contract '${contractAddress}' does not exist`);\n  }\n\n  // Binary search for the block number that the contract was deployed in.\n  const firstBlock = await binarySearchFirstBlock(\n    0,\n    currentBlockNum + 1,\n    contractAddress,\n    alchemy\n  );\n\n  // Find the first transaction in the block that matches the provided address.\n  const txReceipts = await getTransactionReceipts(alchemy, {\n    blockNumber: toHex(firstBlock)\n  });\n  const matchingReceipt = txReceipts.receipts?.find(\n    receipt => receipt.contractAddress === contractAddress.toLowerCase()\n  );\n  return {\n    deployerAddress: matchingReceipt?.from,\n    blockNumber: firstBlock\n  };\n}\n\n/**\n * Refreshes the cached metadata for a provided NFT contract address and token\n * id. Returns a boolean value indicating whether the metadata was refreshed.\n *\n * This method is useful when you want to refresh the metadata for a NFT that\n * has been updated since the last time it was fetched. Note that the backend\n * only allows one refresh per token every 15 minutes, globally for all users.\n * The last refresh time for an NFT can be accessed on the\n * {@link Nft.timeLastUpdated} field.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param contractAddress - The contract address of the NFT.\n * @param tokenId - The token id of the NFT.\n */\nexport async function refreshNftMetadata(\n  alchemy: Alchemy,\n  contractAddress: string,\n  tokenId: BigNumberish\n): Promise<boolean>;\n\n/**\n * Refreshes the cached metadata for a provided NFT contract address and token\n * id. Returns a boolean value indicating whether the metadata was refreshed.\n *\n * This method is useful when you want to refresh the metadata for a NFT that\n * has been updated since the last time it was fetched. Note that the backend\n * only allows one refresh per token every 15 minutes, globally for all users.\n *\n * @param alchemy - The Alchemy SDK instance.\n * @param nft - The NFT to refresh the metadata for.\n */\nexport async function refreshNftMetadata(\n  alchemy: Alchemy,\n  nft: BaseNft\n): Promise<boolean>;\n\nexport async function refreshNftMetadata(\n  alchemy: Alchemy,\n  contractAddressOrBaseNft: string | BaseNft,\n  tokenId?: BigNumberish\n): Promise<boolean> {\n  let contractAddress: string;\n  let tokenIdString: string;\n  if (typeof contractAddressOrBaseNft === 'string') {\n    contractAddress = contractAddressOrBaseNft;\n    tokenIdString = BigNumber.from(tokenId!).toString();\n  } else {\n    contractAddress = contractAddressOrBaseNft.contract.address;\n    tokenIdString = contractAddressOrBaseNft.tokenId;\n  }\n  const first = await getNftMetadata(alchemy, contractAddress, tokenIdString);\n  const second = await refresh(alchemy, contractAddress, tokenIdString);\n  return first.timeLastUpdated !== second.timeLastUpdated;\n}\n\nasync function refresh(\n  alchemy: Alchemy,\n  contractAddress: string,\n  tokenId: BigNumberish\n): Promise<Nft> {\n  const response = await requestHttpWithBackoff<GetNftMetadataParams, RawNft>(\n    alchemy,\n    AlchemyApiType.NFT,\n    'getNFTMetadata',\n    {\n      contractAddress,\n      tokenId: BigNumber.from(tokenId!).toString(),\n      refreshCache: true\n    }\n  );\n  return getNftFromRaw(response, contractAddress);\n}\n\n/**\n * Perform a binary search between an integer range of block numbers to find the\n * block number where the contract was deployed.\n *\n * @internal\n */\nasync function binarySearchFirstBlock(\n  start: number,\n  end: number,\n  address: string,\n  alchemy: Alchemy\n): Promise<number> {\n  if (start >= end) {\n    return end;\n  }\n\n  const mid = Math.floor((start + end) / 2);\n  const code = await alchemy.getProvider().getCode(address, mid);\n  if (code === ETH_NULL_VALUE) {\n    return binarySearchFirstBlock(mid + 1, end, address, alchemy);\n  }\n  return binarySearchFirstBlock(start, mid, address, alchemy);\n}\n\n/**\n * Helper method to convert a NFT response received from Alchemy backend to an\n * SDK NFT type.\n *\n * @internal\n */\nfunction nftFromGetNftResponse(\n  ownedNft: RawOwnedBaseNft | RawOwnedNft\n): Nft | BaseNft {\n  if (isNftWithMetadata(ownedNft)) {\n    return getNftFromRaw(ownedNft, ownedNft.contract.address);\n  } else {\n    return getBaseNftFromRaw(ownedNft, ownedNft.contract.address);\n  }\n}\n\n/**\n * Helper method to convert a NFT response received from Alchemy backend to an\n * SDK NFT type.\n *\n * @internal\n */\nfunction nftFromGetNftCollectionResponse(\n  ownedNft: RawCollectionBaseNft | RawCollectionNft,\n  contractAddress: string\n): Nft | BaseNft {\n  if (isNftWithMetadata(ownedNft)) {\n    return getNftFromRaw(ownedNft, contractAddress);\n  } else {\n    return getBaseNftFromRaw(ownedNft, contractAddress);\n  }\n}\n\n/** @internal */\n// TODO: more comprehensive type check\nfunction isNftWithMetadata(response: RawBaseNft | RawNft): response is RawNft {\n  return (response as RawNft).title !== undefined;\n}\n\n/**\n * Flips the `omitMetadata` SDK parameter type to the `withMetadata` parameter\n * required by the Alchemy API. If `omitMetadata` is undefined, the SDK defaults\n * to including metadata.\n *\n * @internal\n */\nfunction omitMetadataToWithMetadata(\n  omitMetadata: boolean | undefined\n): boolean {\n  return omitMetadata === undefined ? true : !omitMetadata;\n}\n\n/**\n * Interface for the `getNftsForCollection` endpoint. The main difference is\n * that the endpoint has a `startToken` parameter, but the SDK standardizes all\n * pagination parameters to `pageKey`.\n *\n * @internal\n */\ninterface GetNftsForCollectionAlchemyParams {\n  contractAddress: string;\n  startToken?: string;\n  withMetadata: boolean;\n}\n\n/**\n * Interface for the `getNfts` endpoint. The main difference is that the\n * endpoint has a `withMetadata` parameter, but the SDK exposes the parameter as\n * `omitMetadata`.\n *\n * @internal\n */\ninterface GetNftsAlchemyParams {\n  owner: string;\n  pageKey?: string;\n  contractAddresses?: string[];\n  filters?: string[];\n  withMetadata: boolean;\n}\n\n/**\n * Interface for the `getNftMetadata` endpoint.\n *\n * @internal\n */\ninterface GetNftMetadataParams {\n  contractAddress: string;\n  tokenId: string;\n  tokenType?: NftTokenType;\n  refreshCache?: boolean;\n}\n\n/**\n * Interface for the `isSpamContract` endpoint.\n *\n * @internal\n */\ninterface IsSpamContractParams {\n  contractAddress: string;\n}\n\n/**\n * Interface for the `getNftContractMetadata` endpoint.\n *\n * @internal\n */\ninterface GetNftContractMetadataParams {\n  contractAddress: string;\n}\n\n/**\n * Interface for the `getOwnersForCollection` endpoint.\n *\n * @internal\n */\ninterface GetOwnersForCollectionAlchemyParams {\n  contractAddress: string;\n}\n\n/**\n * Interface for the `getFloorPrice` endpoint.\n *\n * @internal\n */\ninterface GetFloorPriceParams {\n  contractAddress: string;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}